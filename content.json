{"pages":[{"title":"","text":"","link":"/movies/index.html"},{"title":"categories","text":"","link":"/categories/index-1.html"},{"title":"","text":"一名爱好算法，即将退役Oier。 加油！ 奥赛（信息学）是条小路，但是它让我学习，见识了许多，感受到了算法带来的魅力；也使我有了模糊的职业规划。 分享 你开始不满足于前端的一亩三分地，你想搞清楚每一个ajax请求背后的事情而不仅仅满足于视其为黑盒子，你想学Java，学PHP，学PY，学SQL，你甚至想从大学本科的计算机底层课程学起，C/C++，操作系统，二进制，编译原理… 原文链接 这段话我看完后很有感触，跟我在初学信奥过程在简直一模一样。（2020-01-17）","link":"/about/index.html"},{"title":"分类","text":"","link":"/categories/index.html"},{"title":"友情链接","text":"加载中，稍等几秒...","link":"/friend/index.html"},{"title":"","text":"留言板 有什么想说的？ 有什么想建议的？ 有什么要吐槽的？ 可以在下方留言……","link":"/message/index.html"},{"title":"快来康康我的摄影～(￣▽￣～)","text":"2019-08 广州行在中山培训的日子里，放假一天，于是就来了个仓促的广州一日游。 2018-07 北京行中考结束。三年没出去旅游的我终于可以happy了。","link":"/photos/index.html"},{"title":"movies","text":"","link":"/movies/index.html"},{"title":"tags","text":"","link":"/tags/index-3.html"},{"title":"tags","text":"","link":"/tags/index-2.html"},{"title":"tags","text":"","link":"/tags/index-1.html"},{"title":"标签","text":"","link":"/tags/index.html"}],"posts":[{"title":"黑红树","text":"题目描述Czy发现黑红树具有一些独特的性质。 这是二叉树，除根节点外每个节点都有红与黑之间的一种颜色。 每个节点的两个儿子节点都被染成恰好一个红色一个黑色。 这棵树你是望不到头的（树的深度可以到无限大） 黑红树上的高度这样定义:h(根节点)=0，h[son]=h[father]+1。 Czy想从树根顺着树往上爬。他有p/q的概率到达红色的儿子节点，有1-p/q的概率到达黑色节点。但是他知道如果自己经过的路径是不平衡的，他会马上摔下来。一条红黑树上的链是不平衡的，当且仅当红色节点与黑色节点的个数之差大于1。现在他想知道他刚好在高度为h的地方摔下来的概率的精确值a/b，gcd(a,b)=0。那可能很大，所以他只要知道a,b对K取模的结果就可以了。另外，czy对输入数据加密：第i个询问Qi真正大小将是给定的Q减上一个询问的第一个值a%K. 格式第一行四个数p,q,T,k，表示走红色节点概率是p/q，以下T组询问，答案对K取模。接下来T行，每行一个数 Q,表示czy想知道刚好在高度Q掉下来的概率（已加密）输出T行，每行两个整数，表示要求的概率a/b中a%K和b%K的精确值。如果这个概率就是0或1，直接输出0 0或1 1（中间有空格）。 样例输入1 2 3 2 10012 样例输出1 0 05 9 样例输入2 2 3 2 2046 样例输出2 0 10 9 这道题的求解顺序应是：求值-&gt;化简-&gt;取模，不能错，错了就是见祖宗。明显的是在奇数层绝对是不会掉下来的，那么就把二层看作一层进行dp。那么在h层刚好掉下来的概率是h-2层活下来的概率 * 连续走两次一样的概率，就是$\\frac{p^2}{q^2}+\\frac{(p-q)^2}{q^2}$，化简一下就好了。那么对活下来的概率dp就行了，（准确来说是递推），应该好搞吧，在h层活的概率就是h-2层活的概率 * 走两次不一样的概率（ps：因为可以先红后黑，或先黑后红，所以要乘2），式子是$\\frac{2p(p-q)}{q^2}$。对活下来的概率先预处理一波，然后询问的话O(1)回答；其实活下来的概率是个等比数列，写出通项公式，对于每个询问进行快速幂运算就好了。想说明的一点是取模之后再约分是不对的，要先把式子约分，这样可以保证算出来的答案一定是真正答案模意义下的，这道题就这个样子。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;bits/stdc++.h&gt;using namespace std;int p,q,t,k;int dp[2][1010101],die[2],live[2];inline int read(){ int x=0; char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')ch=getchar(); while(ch&gt;='0'&amp;&amp;ch&lt;='9'){ x=x*10+(ch^48); ch=getchar(); } return x;}int gcd(int x,int y){ int tep; while(y!=0){ tep=x%y; x=y; y=tep; } return x;}void ready(){ dp[0][0]=dp[1][0]=1; for(int i=1;i&lt;=500000;++i){ dp[0][i]=((long long)dp[0][i-1]*(long long)live[0])%(long long)k; dp[1][i]=((long long)dp[1][i-1]*(long long)live[1])%(long long)k; }}int main(){ p=read();q=read();t=read();k=read(); int gcd_=gcd(p,q); p/=gcd_;q/=gcd_; die[0]=2*p*p+q*q-2*p*q; die[1]=q*q; gcd_=gcd(die[0],die[1]); die[0]/=gcd_;die[1]/=gcd_; live[0]=p*(q-p)*2; live[1]=q*q; gcd_=gcd(live[0],live[1]); live[0]/=gcd_;live[1]/=gcd_; ready(); register int x,y=0,z; while(t--){ x=read(); x-=y; if((x&amp;1)||(x&lt;=0)){ printf(\"0 0\\n\"); y=0; continue; } y=((long long)dp[0][(x&gt;&gt;1)-1]*die[0])%k; z=((long long)dp[1][(x&gt;&gt;1)-1]*die[1])%k; printf(\"%d %d\\n\",y,z); } return 0;}","link":"/posts/notes/hei_hong_shu.html/"},{"title":"Hello World","text":"##Hello,world!","link":"/posts/first/hello-world.html/"},{"title":"三元上升子序列","text":"树状数组求法在做这道前，你需要了解树状数组求逆序对。 首先看这一道题，三元！在二元时，不是跟逆序对一样吗？求逆序对可以用树状数组或归并，那么在三元时，是否也可以呢？ 考虑 $a_i&lt; a_j &lt; a_k$ ，把它拆成两个二元 $a_i &lt; a_j$，$a_j &lt; a_k$ ，两个二元组都与$a_j$有关，那么就考虑中间j，假设第一个不等式有 p 个 a 满足$ &lt; a_j$，第二个有q个$a$满足$ &gt;a_j$，那么以下标为j的答案就为p*q。那不就是算一下每个下标前面比它小的值，后面比它大的值。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;bits/stdc++.h&gt;using namespace std;int n,tree[33333];struct dd{ int v,pos;}a[33333];long long ans=0;int ans1[33333];#define lowbit(x) ((x)&amp;(-x))inline bool cmp(dd x, dd y){ return x.v==y.v?x.pos&gt;y.pos:x.v&lt;y.v; //若相同，将下标值大的放在前面。}void update(int t,int x){ while(t&lt;=n){ tree[t]+=x; t+=lowbit(t); }}int sum(int t){ int tot=0; while(t){ tot+=tree[t]; t-=lowbit(t); } return tot;}inline int read(){ int x=0; char ch=getchar(); while(ch&gt;'9'||ch&lt;'0')ch=getchar(); while(ch&gt;='0'&amp;&amp;ch&lt;='9'){ x=x*10+(ch^48); ch=getchar(); } return x;}int main(){ n=read(); for(int i=1;i&lt;=n;++i){ a[i].v=read(); a[i].pos=i; } sort(a+1,a+1+n,cmp);//从小到大排序 for(int i=1;i&lt;=n;++i){ ans1[i]=sum(a[i].pos-1); //下标大的先计算，不会影响下标比它小相同数的统计 update(a[i].pos,1); } memset(tree,0,sizeof(tree)); for(int i=n;i&gt;=1;--i){ //倒序枚举，此时是下标小先计算，不会影响下标比它大相同数的统计 ans+=(long long)ans1[i]*(sum(n-a[i].pos)); update(n-a[i].pos+1,1); } printf(\"%lld\",ans);} 此题可以拓展到k元上升序列，推荐个大佬博客。","link":"/posts/notes/san_yuan_shang_sheng_xu_lie.html/"},{"title":"开启Valine评论功能","text":"首先需要在Leancloud官网注册并登录，然后点击创建应用（ps：应用名称最好填你的博客名，这是为了邮箱提醒）。 创建好应用后，点击应用设置，找到应用Keys，将箭头所指的两个复制下来。 打开你的博客下的themes/***/_config.yml，找到如下图的内容，将它们粘贴上去。 在Leancloud中设置-安全中心-web安全域名中输入你的网站。（这一步貌似可以跳过） 之后 12hexo ghexo d 就算是初步打造好了。 如果你想要开启邮箱提醒，在主题配置里设置notify为true。回到Leancloud,进行如下操作。 1234567你在 {{appname}}博客中的评论收到了新的回复&lt;p&gt;Hi, {{username}}&lt;/p&gt;&lt;p&gt;你在 {{appname}} 的博客中的评论收到了新的回复，请点击查看：&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;你的网站主&quot; style=&quot;display: inline-block; padding: 10px 20px; border-radius: 4px; background-color: #3090e4; color: #fff; text-decoration: none;&quot;&gt;马上查看&lt;/a&gt;&lt;/p&gt; 如何还有疑问，请评论或访问Valine官网","link":"/posts/shi_yong/Valine.html/"},{"title":"飞行路线 改造路 分层最短路【模板】","text":"P4568 P2939 给你一张带权图,你可以用不大于K次机会免费通过一条边(或者是以其他费用通过),问你从起点到终点最短路径. 分层最短路就是用来处理这一问题的,其实就是变了点形的Dp,只是名字高级了一点.貌似也只能处理这一问题了.$Dp$无非就是设$dp[i][j]$,其意就是到达$i$点用了$j$次机会所用的最小花费. 而分层最短路大概就是把图扩充为好几层,每一层代表的含义就是使用了几次机会.如果到了下一层那么就是免费(或其他),在这一层里走就是正常花费.其实还是挺好理解的(Ps:只是把二维的Dp变成了一维). 而且代码只是在最短路的代码上多连了几条边,一般都是用堆优化的$Dij$跑,因为给你的点数一般为10000,而且边不算稀,用SPFA较慢.上代码. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;bits/stdc++.h&gt;using namespace std;struct Mystruct{ int ne,to,w;}edge[4105050];int n,m,k,head[212020],tail,dis[212020];bool v[212020];#define add(x,y,z) edge[++tail].ne=head[x];edge[tail].to=y;edge[tail].w=z;head[x]=tail;void dij(){ priority_queue&lt;pair&lt;int,int&gt; &gt;q; //用优先队列码量小,跟堆的作用一样 //pair为二元组,把俩者绑在一起,默认的是先从第一个比较大小,若相等则比较第二个 //此时这里默认的是大根堆,此时可以自定义比较,或者把dis把它变成负的就ok了 //可以这样 priority_queue&lt;pair&lt;int,int&gt;,vector&lt;pair&lt;int,int&gt; &gt;,greater&lt;pair&lt;int,int&gt; &gt; &gt;q //又长又臭, 倾向于第二种 q.push(make_pair(0,1));//就当起点是1,终点是N了 while(!q.empty()){ int x=q.top().second; //pair以 .first 访问第一个,以 .second 访问第二个 q.pop(); if(v[x])continue; v[x]=1; for(int i=head[x];i;i=edge[i].ne){ int diss=dis[x]+edge[i].w; if(dis[edge[i].to]&gt;=diss){ dis[edge[i].to]=diss; q.push(make_pair(-diss,edge[i].to)); } } }}int main(){ scanf(\"%d%d%d\",&amp;n,&amp;m,&amp;k); for(int i=1,x,y,z;i&lt;=m;++i){ scanf(\"%d%d%d\",&amp;x,&amp;y,&amp;z); add(x,y,z); add(y,x,z); //第0层互相连边 for(int j=1;j&lt;=k;++j){ add(x+(j-1)*n,y+j*n,0); add(y+(j-1)*n,x+j*n,0); //第j-1层与第j层连边 add(y+j*n,x+j*n,z); add(x+j*n,y+j*n,z); //第j层互相连边 } } //初始化 for(int i=1;i&lt;=n*(k+1);++i) dis[i]=0x7fffffff; dis[1]=0; dij(); int ans=0x7fffffff; //别忘了可能还没用够K次机会就到终点了 for(int i=n;i&lt;=n*(k+1);i+=n) ans=min(ans,dis[i]); printf(\"%d\",ans);}","link":"/posts/notes/fen_ceng_zui_duan_lu.html/"},{"title":"树【树形Dp】","text":"题目描述 图论中的树为一个无环的无向图。给定一棵树，每个节点有一盏指示灯和一个按钮。如果节点的按扭被按了，那么该节点的灯会从熄灭变为点亮（当按之前是熄灭的），或者从点亮到熄灭（当按之前是点亮的）。并且该节点的直接邻居也发生同样的变化。 开始的时候，所有的指示灯都是熄灭的。请编程计算最少要按多少次按钮，才能让所有节点的指示灯变为点亮状态。 输入格式输入文件有多组数据。 输入第一行包含一个整数n，表示树的节点数目。每个节点的编号从1到n。 输入接下来的n – 1行，每一行包含两个整数x，y，表示节点x和y之间有一条无向边。 当输入n为0时，表示输入结束。 输入样例31 21 3 输出样例：1 输出格式对于每组数据，输出最少要按多少次按钮，才能让所有节点的指示灯变为点亮状态。每一组数据独占一行。 $f_{i,0}$表示以$i$为根的子树都亮，并且$i$开$f_{i,1}$表示以$i$为根的子辈都亮，$i$没开，$i$亮$f_{i,2}$表示以$i$为根的子辈都亮，$i$没开，$i$不亮$s=\\sum_j min(f_{j,0},f_{j,1})$初始t = 0if($f_{j,0}&lt;f_{j,1}$)$t$^$=1$t = 0 代表着 i 不会亮，t = 1 就代表着 i 会亮$minn=min(abs(f_{j,0}-f_{j,1}))$$f_{i,1}=s+(t?0:minn)$$f_{i,2}=s+(t?minn,0)$$f_{i,0}=\\sum_{j}f_{j,2}+1$ 12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;bits/stdc++.h&gt;using namespace std;#define add(x,y) edge[++tail]=(dd){head[x],y};head[x]=tail;struct dd{ int ne,to;}edge[500];int head[111],tail,n;long long f[111][3];void dfs(int t,int fa){ f[t][0]=1; int tt=0; long long minn=1000000,s=0; for(int i=head[t];i;i=edge[i].ne){ if(edge[i].to!=fa){ dfs(edge[i].to,t); s+=min(f[edge[i].to][1],f[edge[i].to][0]); if(f[edge[i].to][0]&lt;f[edge[i].to][1])tt^=1; minn=min(minn,abs(f[edge[i].to][1]-f[edge[i].to][0])); f[t][0]+=f[edge[i].to][2]; } } f[t][1]=s+(tt?0:minn); f[t][2]=s+(tt?minn:0);}int main(){ while(1){ scanf(\"%d\",&amp;n); if(n==0)return 0; memset(head,0,sizeof(head)); memset(f,0,sizeof(f)); tail=0; for(int i=1,x,y;i&lt;n;++i){ scanf(\"%d%d\",&amp;x,&amp;y); add(x,y);add(y,x); } dfs(1,1); printf(\"%d\\n\",min(f[1][0],f[1][1])); } return 0;}","link":"/posts/notes/shu_xing_Dp.html/"},{"title":"感想录","text":"2019-12-xx 在数学课上，数学老师不知道为什么扯到了奥赛，说了一句省一有什么用？当着全班同学的面摔凳子。之前他就说过那句话，当时只是冲老师笑了笑，现在又说了一句🙂。 考试前夕，老师，同学和家长说着我要拿个省一。当时跟他们说着一定，实际上我是有些害怕的，万一没有拿着省一，老师，同学，家长会怎么看我……我只好不停地学习着。好在是拿到了，没有那么多压力了。 我知道奥赛（信息学）是条小路，但是它让我学习，见识了许多，感受到了算法带来的魅力；也使我有了模糊的职业规划。 加油吧！","link":"/posts/sundries/thinks.html/"},{"title":"点的距离【欧拉序列】","text":"原题链接：点的距离loj10130题目描述给定一棵 N个点的树，Q个询问，每次询问点x到点y两点之间的距离。 输入格式第一行一个正整数N，表示这棵树有 N个节点； 接下来N-1行，每行两个整数x y表示x，y有两条连边 然后一个整数Q，表示有Q个询问 接下来Q行每行两个整数x y 表示询问x到y的距离 输出格式输出Q行，每行表示每个询问的答案。 样例输入12345678961 21 32 42 53 622 65 6 样例输出1234 平常在信息学竞赛中求LCA一般有四种办法： 倍增法求解，预处理复杂度是 O(nlog⁡n) ,每次询问的复杂度是 O(log⁡n), 属于在线解法。 利用欧拉序转化为RMQ问题，用ST表求解RMQ问题，预处理复杂度 O(n+nlogn) ，每次询问的复杂度为 O(1)， 也是在线算法。 采用Tarjan算法求解，复杂度 O(α(n)+Q) ，属于离线算法。 利用树链剖分求解，复杂度预处理O(n) ，单次查询 O(log⁡n) ，属于在线算法。 主要的为倍增法和欧拉序列 如果询问量巨大的话，欧拉序列法明显占优 欧拉序+st表温馨提示，若想更好地阅读本文章，你需要掌握一下知识： 可以dfs一棵树 熟知st表 首先对有根树t进行dfs（深度优先遍历），无论是递归还是回溯，每次到达一个结点时都将深度记录下来，可以得到一个长度为2n-1的序列，称为t的欧拉序列f(类似于欧拉回路)为了方便，把结点k在欧拉序列中第一次出现的序号记为pos(k)。有了欧拉序列，Lca问题可以在线性时间内化为RMQ问题：Lca(t,u,v)=RMQ(f,pos(u),pos(v)) ，这里RMQ返回的是所求值的下标，若需求两个点的距离，利用deep[u]+deep[v]-(2*deep[Lca(t,u,v)] 即可求得。 这个等式不难理解：从u走到v的过程中一定会经过Lca(t,u,v)，但不会经过Lca(t,u,v)的祖先。因此，从u走到v的过程中经过的深度最小的结点就是Lca(t,u,v)。用Dfs计算欧拉序列的时间复杂度O(n)，欧拉序列的长度是2n-1，所以空间复杂度O(n)，所以Lca问题可以在O(n)的时间内用O(n)的空间转化成等规模的RMQ问题。 此处引用刘汝佳算法竞赛入门经典 Dfs计算欧拉序列： 1234567891011void dfs(int t, int fa, int deepth) { for (int i = head[t]; i; i = side[i].next) { if (side[i].to != fa) { Dfsxu[++tail_Dfsxu] = side[i].to;//开始遍历儿子 Deep[tail_Dfsxu] = deepth + 1; Dfs(side[i].to, t, deepth + 1); Dfsxu[++tail_Dfsxu] = t;//以儿子为根的子树已经遍历过了 Deep[tail_Dfsxu] = deepth;//往回走到他爸这里，准备遍历下一个儿子 } }} 现在已经知道深度了，先预处理一下st： 12345678910void st_ready() { //由于cmath里log函数处理比较慢，这里进行预处理一下 lg[0]=-1; mi[0]=1; for (int i = 1; i &lt;= (n &lt;&lt; 1); ++i) lg[i] = lg[i &gt;&gt; 1] + 1; for (int i = 1; i &lt;= 18; ++i) mi[i] = (mi[i - 1] &lt;&lt; 1); for (int i = 1; i &lt;= lg[(n &lt;&lt; 1) - 1]; ++i) for (int j = 1; j + mi[i] - 1 &lt;= ((n &lt;&lt; 1) - 1); ++j) st[i][j] = min(st[i - 1][j], st[i - 1][j + mi[i - 1]]);} 此时已经将Lca问题转化为Rmq问题了，这时我们还需要知道每个节点在欧拉序列的第一次出现的位置，用first[i]记录当前i节点在欧拉序列中的下标，这个可以直接在求欧拉序的时候顺带求出。 123456789101112void dfs(int t, int fa, int deepth) { for (int i = head[t]; i; i = side[i].next) { if (side[i].to != fa) { Dfsxu[++tail_Dfsxu] = side[i].to;//开始遍历儿子 Deep[tail_Dfsxu] = deepth + 1; first[side[i].to] = tail_Dfsxu;//这是就是个该节点第一次出现的位置 Dfs(side[i].to, t, deepth + 1); Dfsxu[++tail_Dfsxu] = t;//以儿子为根的子树已经遍历过了 Deep[tail_Dfsxu] = deepth;//往回走到他爸这里，准备遍历下一个儿子 //之前t已经出现了，这里就不能first记录了 } } 整体思路就是这样，下面附完整代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;bits/stdc++.h&gt;using namespace std;int head[100011], tail, tail_dfs = 1, dfsxu[200012], n, q, lg[200012] = { -1 }, mi[19] = { 1 }, st[19][200011], first[100012];struct dd { int next, to;}side[200012];//邻接列表存储inline void add(int x, int y) { side[++tail].to = y; side[tail].next = head[x]; head[x] = tail;}void dfs(int t, int fa, int deepth) { for (int i = head[t];i;i = side[i].next) { if (side[i].to != fa) { dfsxu[++tail_dfs] = side[i].to; st[0][tail_dfs] = deepth + 1;//这里直接用st存储深度了 first[side[i].to] = tail_dfs; dfs(side[i].to, t, deepth + 1); dfsxu[++tail_dfs] = t; st[0][tail_dfs] = deepth; } }}void st_ready() { for (int i = 1;i &lt;= (n &lt;&lt; 1);++i) lg[i] = lg[i &gt;&gt; 1] + 1; for (int i = 1;i &lt;= 18;++i) mi[i] = (mi[i - 1] &lt;&lt; 1); for (int i = 1;i &lt;= lg[(n &lt;&lt; 1) - 1];++i) for (int j = 1;j + mi[i] - 1 &lt;= ((n &lt;&lt; 1) - 1);++j) st[i][j] = min(st[i - 1][j], st[i - 1][j + mi[i - 1]]);}int main() { scanf(\"%d\", &amp;n); for (int i = 1, x, y;i &lt; n;++i) { scanf(\"%d%d\", &amp;x, &amp;y); add(x, y); add(y, x); } dfsxu[1] = 1; st[0][1] = 1; first[1] = 1; dfs(1, 0, 1); st_ready(); scanf(\"%d\", &amp;q); while (q--) { int x, y; scanf(\"%d%d\", &amp;x, &amp;y); int l = first[y], r = first[x];//输入下x,y的时候，我们不知道谁先出现在欧拉序列中的， if (r &lt; l)swap(l, r); //所以需要判断一下 int log = lg[r - l + 1]; printf(\"%d\", st[0][l] + st[0][r] - (min(st[log][l], st[log][r - mi[log] + 1]) &lt;&lt; 1));//l的深度+r的深度-公共祖先的深度*2 putchar('\\n'); //这个公式好理解吧 }} 欢迎各位大佬指出意见","link":"/posts/notes/dian_de_ju_li.html/"},{"title":"链接合辑","text":"推荐些游戏： http://nazo.one-story.cn（最先入坑的这个）https://nazo.io/1https://nazo.games/ 超级有意思 这些解密游戏需要些计算机知识，或许还需要一些密码学？反正合我胃口😋 推荐些神贴：链接太丑，点击我！09年神贴，一个男的给一个女生表白，女的给了他个密码，说解出来了跟他约会。具体细节自己看吧。答案在207楼。这个男的发了贴之后就没动静了，真想知道结果怎样🤔，毕竟11年了。","link":"/posts/sundries/web_links.html/"},{"title":"noip2018","text":"离第一届CSP还有4天时，考了一次noip2018。 Day 1T1惊了，这是签到题吗？？？（ps:noip2013没做过)，思路还是比较好想的，用的线段树维护的，太菜了，还好A了，一个小时过去了。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include&lt;bits/stdc++.h&gt;using namespace std;int n,ans;int a[100505];struct dd{ int minn,flag,pos;}tree[405050];void putup(int pos,int ls,int rs){ if(tree[ls].minn&lt;tree[rs].minn){ tree[pos].minn=tree[ls].minn; tree[pos].pos=tree[ls].pos; } else { tree[pos].minn=tree[rs].minn; tree[pos].pos=tree[rs].pos; }}void build(int pos,int l,int r){ if(l==r){ tree[pos].minn=a[l]; tree[pos].pos=l; return; } int mid=l+r&gt;&gt;1,ls=pos&lt;&lt;1,rs=ls|1; build(ls,l,mid); build(rs,mid+1,r); putup(pos,ls,rs);}inline void putdown(int pos,int ls,int rs){ tree[ls].minn+=tree[pos].flag; tree[rs].minn+=tree[pos].flag; tree[ls].flag+=tree[pos].flag; tree[rs].flag+=tree[pos].flag; tree[pos].flag=0;}void modify(int pos,int l,int r,int ll,int rr,int x){ if(ll&lt;=l&amp;&amp;r&lt;=rr){ tree[pos].flag+=x; tree[pos].minn+=x; return ; } int mid=l+r&gt;&gt;1,ls=pos&lt;&lt;1,rs=ls|1; if(tree[pos].flag)putdown(pos,ls,rs); if(ll&lt;=mid)modify(ls,l,mid,ll,rr,x); if(mid&lt;rr)modify(rs,mid+1,r,ll,rr,x); putup(pos,ls,rs);}dd ques(int pos,int l,int r,int ll,int rr){ if(ll&lt;=l&amp;&amp;r&lt;=rr){ return tree[pos]; } int mid=l+r&gt;&gt;1,ls=pos&lt;&lt;1,rs=ls|1; if(tree[pos].flag)putdown(pos,ls,rs); dd minn; minn.minn=0x3f3f3f3f; if(ll&lt;=mid)minn=ques(ls,l,mid,ll,rr); if(mid&lt;rr){ dd noww=ques(rs,mid+1,r,ll,rr); if(noww.minn&lt;minn.minn){ minn=noww; } } return minn;}void work(int l,int r){ dd minn=ques(1,1,n,l,r); ans+=minn.minn; if(minn.minn)modify(1,1,n,l,r,-minn.minn); if(l&lt;=minn.pos-1)work(l,minn.pos-1); if(minn.pos&lt;r)work(minn.pos+1,r);}int main(){// freopen(\"road.in\",\"r\",stdin);// freopen(\"road.out\",\"w\",stdout); scanf(\"%d\",&amp;n); for(int i=1;i&lt;=n;++i) scanf(\"%d\",&amp;a[i]); build(1,1,n); work(1,n); printf(\"%d\",ans); return 0;} T2一眼想到小凯的疑惑（noip2017），然后使尽各种方法还是不会，此时已经知道第一小的一定不会被删，留下来的数绝对都是互质的，在加上T2一般都是Dp，然后就联想到了货币系统（名字一样），给你几种面值不同的货币，让你求组成价值v方案总数。 那么对于这道题来说，只要求出哪些数对组成不同的价值有贡献就行，然后我就让背包容量设为最小互质的两个数最大不能表达的数（参见小凯的疑惑）是它，就是它，坑了我，因为后面的数都可以被表示出来，样例对了，有手玩了几个数据也对了，可恶的是大样例在最后20分钟才发，试了一下大样例,emmm…，发现背包容量可能高达6亿….然后就把数组调到50000000就没管了。 竟然才35！！！！ 唉！也不知道考场上怎么会那样想，只要求出那些数不能被其他数表示出来就okkk了啊啊啊！！！把背包容量设为最大的那个数就A了。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;bits/stdc++.h&gt;using namespace std;int a[25550];int f[50000];int gcd(int x,int y){ while(y){ int t=x%y; x=y; y=t; } return x;}int main(){// freopen(\"money.in\",\"r\",stdin);// freopen(\"money.out\",\"w\",stdout); int t; scanf(\"%d\",&amp;t); while(t--){ int n; memset(f,0,sizeof(f)); f[0]=1; scanf(\"%d\",&amp;n); register int min1=0x3f3f3f3f,min2=0x3f3f3f3f,ans=0; for(register int i=1;i&lt;=n;++i) scanf(\"%d\",&amp;a[i]); sort(a+1,a+1+n); if(a[1]==1){ printf(\"1\\n\"); continue; } register int gc=2,tail=1; for(register int i=1;i&lt;=n;++i){ int pd=0; for(register int j=a[i];j&lt;=a[n];++j){ if(f[j])continue; else if(f[j-a[i]]){ f[j]=1; pd=1; } } if(pd)ans++; } printf(\"%d\\n\",ans); } return 0;} T3一眼就不会嘛，果断的把m=1的情况给水了，然后在想怎么水一条链上的，大概就是尽量m等分，发现暴力的话复杂度太高，此时也快结束了，弃疗了。 听同学说，在一条链上，二分答案就行了。20分就这样没了。。 就水了20分，本来可以40分的。 Day 1 100+35+20=155 凉了！","link":"/posts/sundries/noip2018.html/"},{"title":"csp2019爆零记","text":"Day 016:00到的酒店,大学还行吧。算是第二次到这里了。 考场是按姓氏排的，首字母为z的我表示很无奈，与大部队分开，只有3个人和我一起一栋楼。键盘比较新，超级nice（ps：相对于另一栋楼的键盘），屏幕还是上一次的样子，还行。在洛谷上A了到红题就走了。 晚上的话，写矩阵取数，一晚上也没A掉。 Day 1emmmm…我进的考场它键盘不是新的！！！包浆的键盘！！！ 可能是第一次考csp吧，进考场后感觉整个人都是懵的。 解压后，看了第一题，整个人都慌了。看了20分钟后，感觉有思路了，当时想的是找到第一个$2^j -1&gt;=k$，对它进行处理，然后在前面补上$n-j$个0，递归嘛。然后打了个zz程序，死活过不了我试的数据，心态再次大崩（qwq，突然想到这一行跟上一行有关系，上一行又跟上上一行有关系，如果$k&gt;\\frac{2^{n}-1}{2}$,输出1再处理第n-1行第$\\left(2^{n}-1\\right)-k$个就行了啊，然后迅速改了改，试了试样例都过了，极限数据也过了，然后就搞第二题了，已经过了一个小时了。 第二题，emmmm~~，一开始感觉是可做的，然后先考虑链的情况，理解错了，设了个n方dp，试了试几组数组，成功发现思路错误，已经过了好久。心态大崩*2，于是就打了个n方与n三方直接的暴力，调试了半天。 到第三题的时候好像还剩40多分钟，那是时内心已经绝望了，一开时想链没有什么思路，又看了看菊花图感觉讨论着好麻烦啊，又回去考虑了链的情况，想到了类似贪心的策略，一看时间还剩20分钟，果断弃疗，打了个冒泡就扔了。 唉！Day 1 就这样了。晚上刷了会儿B站，心情好多了。 Day 2真三道不可做题。太弱了，暴力都不会打，但今天心态要比昨天的好，然并卵。第一道题看了40分钟，硬是没看懂题意，语文太菜了，弃了。第二道暴力都不知怎么打，先过了。第三题貌似还是可以水55分的，就这55分搞了半天。还剩半个小时，第一题实在搞不懂，搞第二题了。打了个貌似贪心的n方，知道是错的，没法子呐！","link":"/posts/travel/csp2019.html/"},{"title":"中山8.23","text":"今日总结 T1:感觉题目说的有点小问题(还是太菜le),导致我做法比较玄学…搞了70分. T2:裸啊!(还是不会)根据题意可以转化成n个相同的小球放进m个不同的盒子里,不允许为空.用隔板法(通过背结论)可以推出方案数为$c_{n-1}^{m-1}$,emmm…我没背啊!!! （以下为口胡,有错别怪我）但我发现可以通过数的划分变形得到,$(1,1,2)$,$(1,2,1)$,$(2,1,1)$在这道题中为3中不同的方案,但在数的划分中认为是同一种方案,但我每得到一种答案,就把它乘不全相异元素排列方案数( $\\frac {n!}{n_{1}!n_2!…n_{m-1}!*n_m!}$ )…就ok了…但在码时,我发现我数的划分也不会了..凉! T3:先鸽着…题懒得看了 T4:emmmm….只做过一维的，二维的是什么鬼…. 正解: 三维偏序???","link":"/posts/travel/Zhongshan/8.23.html/"},{"title":"中山8.20","text":"今日总结 T1:表示完全没有思路，于是就打起了贪心,然后0分??? (之前贪心总能拿点分呐!) 正解是dp乱搞??? T2:就这道题有点思想了,结果样例没看懂… 正解还是dp…设$f[i]$为i个时间内回到家的方案数,在这i个时间内可能经过家,也可能没有经过.这..这不就是卡特兰数吗?但不是…因为在这道题中限制了在最多m个时间内回到家. 再设$Dp[i]$为i个时间内刚好回到家的方案数,在这i个时间内没有经过家,则$f[i]=\\sum_{j=1}^{min(i,m)}{f[i-j]*Dp[j]}$.这个$Dp[i]$也形似卡特兰数,可惜也不是,因为卡特兰数0可以与1相等,不符合我们的要求,但我们可以略加改进. 考虑卡特兰数可以走到对角线上,但我们并不想让它走到上面,于是我们在这个对角线下再画一条线,先向右走1格,求出到从(0,1)到(5,4)的方案数即可.在这道题中即可以先向左,也可以先向右.所以将求出的方案数*2即可. 如图所示： 由于n比较大，所以需要用矩阵快速幂优化,这里就跳过了. T3：完全没得思路,想找循环发现不是,于是果断暴力走起。 正解是神仙类欧??? 不会…","link":"/posts/travel/Zhongshan/8.20.html/"},{"title":"中山8.21","text":"今日总结 都不会！！！T1:最小生成树???最小比例生成树….我想着用状压枚举哪些点选…然后想了想点之间可能会很多边,不会处理(蒟蒻一个),果断放弃. 正解是跑好几遍最小生成树…. T2:完全不会,没往$Dp$上想… 设$Dp[i][j]$为第$i$个人什么的,让我再想想. T3:凭借这10%的数据$n=0$水了十分…然后就不会了… 把球心和起点与终点互相连起来,距离就是点之间的距离减上两个点所在的球的半径…跑一边$Dij$就ok了. T4:想法和正解相差甚远…想着有什么奇淫技巧…结果这么暴力. 跑一遍最短路,然后枚举删哪一个点,然后再跑最短路,再枚举…知道最短路径大于$k$.这么暴力的吗 争取把今天题改完吧(也许可能吧.","link":"/posts/travel/Zhongshan/8.21.html/"},{"title":"中山8.9","text":"今日总结 T1. 水（可惜我不会打…） 先bfs跑一遍洪水泛滥的，记录一下每个位置在哪一秒时被淹了。然后再bfs跑一遍人,在下一个时刻不能跑洪水泛滥的以及石头所在的，直到遇到住所中break就行了。 T2. 是一道状压题（没看出来…）跟棋盘放置差不多 打的dfs，死活printf不了long double,然后就手动保留小数（忘了进位问题…)然后就40。原来要用%Lf输出，95呐，就超时了一个点（还是数据水） T3. 单调栈（没听过…) T4. Tarjan缩点乱搞（不会不会） 看来不会的还有很多呐！数据结构方面要加强，图论要加强，dp要加强，模拟要加强。（貌似吧考的都说完了）","link":"/posts/travel/Zhongshan/8.9.html/"}],"tags":[{"name":"题解","slug":"题解","link":"/tags/%E9%A2%98%E8%A7%A3/"},{"name":"the first","slug":"the-first","link":"/tags/the-first/"},{"name":"实用","slug":"实用","link":"/tags/%E5%AE%9E%E7%94%A8/"},{"name":"杂项","slug":"杂项","link":"/tags/%E6%9D%82%E9%A1%B9/"},{"name":"其他","slug":"其他","link":"/tags/%E5%85%B6%E4%BB%96/"},{"name":"游记","slug":"游记","link":"/tags/%E6%B8%B8%E8%AE%B0/"},{"name":"中山","slug":"中山","link":"/tags/%E4%B8%AD%E5%B1%B1/"}],"categories":[{"name":"notes","slug":"notes","link":"/categories/notes/"},{"name":"first","slug":"first","link":"/categories/first/"},{"name":"shi_yong","slug":"shi-yong","link":"/categories/shi-yong/"},{"name":"sundries","slug":"sundries","link":"/categories/sundries/"},{"name":"travel","slug":"travel","link":"/categories/travel/"},{"name":"Zhongshan","slug":"travel/Zhongshan","link":"/categories/travel/Zhongshan/"}]}