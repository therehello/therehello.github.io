<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>There,hello</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.therehello.top/"/>
  <updated>2020-07-26T05:50:00.277Z</updated>
  <id>https://www.therehello.top/</id>
  
  <author>
    <name>There,hello</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>链接合辑</title>
    <link href="https://www.therehello.top/posts/sundries/web_links.html/"/>
    <id>https://www.therehello.top/posts/sundries/web_links.html/</id>
    <published>2020-01-06T16:00:00.000Z</published>
    <updated>2020-07-26T05:50:00.277Z</updated>
    
    <content type="html"><![CDATA[<p><strong>推荐些小游戏：</strong></p><a id="more"></a><p><a href="http://nazo.one-story.cn（最先入坑的这个）" target="_blank" rel="noopener">http://nazo.one-story.cn（最先入坑的这个）</a><br><a href="https://nazo.io/1" target="_blank" rel="noopener">https://nazo.io/1</a><br><a href="https://nazo.games/" target="_blank" rel="noopener">https://nazo.games/</a>  </p><blockquote><p>超级有意思  </p></blockquote><p>这些解密游戏需要些计算机知识，或许还需要一些密码学？反正合我胃口😋</p><p><strong>推荐些神贴：</strong><br><a href="http://tieba.baidu.com/mo/q---237FA0D4B92A909F75C00D7C576AAAF1:FG=1--1-1-0--2--wapp_1580661969782_619/m?pnum=1&kz=529691897&see_lz=0&tnum=67211&pinf=&pn=180&r=0&pd=0&lp=6006&sub=%E8%B7%B3%E9%A1%B5" target="_blank" rel="noopener">链接太丑，点击我！</a><br>09年神贴，一个男的给一个女生表白，女的给了他个密码，说解出来了跟他约会。具体细节自己看吧。答案在207楼。这个男的发了贴之后就没动静了，真想知道结果怎样🤔，毕竟11年了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;推荐些小游戏：&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="sundries" scheme="https://www.therehello.top/categories/sundries/"/>
    
    
      <category term="其他" scheme="https://www.therehello.top/tags/%E5%85%B6%E4%BB%96/"/>
    
  </entry>
  
  <entry>
    <title>感想录</title>
    <link href="https://www.therehello.top/posts/sundries/thinks.html/"/>
    <id>https://www.therehello.top/posts/sundries/thinks.html/</id>
    <published>2019-12-19T16:00:00.000Z</published>
    <updated>2021-01-01T04:22:57.218Z</updated>
    
    <content type="html"><![CDATA[<p><strong>2020-8-15</strong></p><p>经常有这样一句话说，正义可能会迟到，但从不会缺席。这句话咋一听没有错，可是细细想来，迟到的正义算是正义吗？像最近热度很高的张玉环案，从1993年被警方逮捕，在看守所度过了7个年头，又在大牢里度过了了19个年头。从自由到自由，这整整花了26个年。这期间张玉环都是没有人身自由的，并且以杀人犯的身份度过。若不是张玉环和他的家人坚持不懈地每周向法院提起申诉，若不是来自北京的律师发现了这个冤案，张玉环究竟什么时候才能和他的家人团聚呢？虽然最终正义到来，但这却花了26年。这26年什么概念，中国男子平均年龄74岁，这1/3的时间都花在了监狱里，且不说这26年正是一个人最为青春，最有力量的时期。我认为迟来的正义就像过期的牛奶，不仅没有营养还会引起呕吐。这也许对社会交代及此，但对于张玉环需要有更多的交代。</p><p>张玉环在接受央视采访时表示：“我需要的不仅仅是一句道歉。”是啊！这些不是一句道歉就能解决的。政府不仅需要对张玉环道歉，而且还需对他的家人道歉。试想这二十六年,他的家人受到了多少人的杂言杂语，多少人的差别对待。他的妻子可能因为他丈夫杀人犯的原因而找不到工作，他的子女可能因为父亲是杀人犯而受到班上同学的嘲笑······政府不仅要对他赔偿,还需将此事件彻查到底，将细节公示于众，这样或许才能弥补一些张玉环所受到的创伤吧。</p><p>我第一次看到这个新闻是在回家的路上，看到这新闻，再看看这路上这繁华的景象。还有多少人性的脸恶没有被公示于众呢?又有多少个张玉环案没有平反呢?想到这里，泪不仅润红的眼眶，心里有所悸动。回家又了解到张玉环被抓那几年正是国家严打罪的几年，当时杀害两名儿童在当地是多么惊动性的事件，当地警方和群众都想快点抓住凶手，以还公道。就因张玉环在接受警方询问的时候行为有些慌乱就被警方逮捕。之后张玉环就受到了生不如死的刑讯逼供，一开始整方只是让他承认，并未做出伤害张玉环的事情，到了后来警方直接放两条恶狗咬他逼他认供，他当年是要有多么绝望啊！</p><p>但不得不承认的是我国的法制建设越来越完善，社会是逐渐进步的，否则张玉环哪有沉冤昭雪的一天，希望正义之花能遍开祖国的各个角落，希望不再有人的目光被蒙上了后尘。</p><p><strong>2019-12-xx</strong></p><p>在数学课上，数学老师不知道为什么扯到了奥赛，说了一句省一有什么用？当着全班同学的面摔凳子。之前他就说过那句话，当时只是冲老师笑了笑，现在又说了一句🙂。</p><p>考试前夕，老师，同学和家长说着我要拿个省一。当时跟他们说着一定，实际上我是有些害怕的，万一没有拿着省一，老师，同学，家长会怎么看我……我只好不停地学习着。好在是拿到了，没有那么多压力了。</p><p>我知道奥赛（信息学）是条小路，但是它让我学习，见识了许多，感受到了算法带来的魅力；也使我有了模糊的职业规划。</p><p>加油吧！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;2020-8-15&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;经常有这样一句话说，正义可能会迟到，但从不会缺席。这句话咋一听没有错，可是细细想来，迟到的正义算是正义吗？像最近热度很高的张玉环案，从1993年被警方逮捕，在看守所度过了7个年头，又在大牢里度过了了19个年
      
    
    </summary>
    
    
      <category term="sundries" scheme="https://www.therehello.top/categories/sundries/"/>
    
    
      <category term="杂项" scheme="https://www.therehello.top/tags/%E6%9D%82%E9%A1%B9/"/>
    
  </entry>
  
  <entry>
    <title>csp2019爆零记</title>
    <link href="https://www.therehello.top/posts/travel/csp2019.html/"/>
    <id>https://www.therehello.top/posts/travel/csp2019.html/</id>
    <published>2019-11-14T16:00:00.000Z</published>
    <updated>2020-07-26T05:46:37.108Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Day-0"><a href="#Day-0" class="headerlink" title="Day 0"></a>Day 0</h2><p>16:00到的酒店,大学还行吧。算是第二次到这里了。  </p><p>考场是按姓氏排的，首字母为z的我表示很无奈，与大部队分开，只有3个人和我一起一栋楼。键盘比较新，超级nice（ps：相对于另一栋楼的键盘），屏幕还是上一次的样子，还行。在洛谷上A了到红题就走了。  </p><a id="more"></a><p>晚上的话，写矩阵取数，一晚上也没A掉。</p><h2 id="Day-1"><a href="#Day-1" class="headerlink" title="Day 1"></a>Day 1</h2><p>emmmm…我进的考场它键盘不是新的！！！包浆的键盘！！！ 可能是第一次考csp吧，进考场后感觉整个人都是懵的。 </p><p>解压后，看了第一题，整个人都慌了。看了20分钟后，感觉有思路了，当时想的是找到第一个$2^j -1&gt;=k$，对它进行处理，然后在前面补上$n-j$个0，递归嘛。然后打了个zz程序，死活过不了我试的数据，心态再次大崩（qwq，突然想到这一行跟上一行有关系，上一行又跟上上一行有关系，如果$k&gt;\frac{2^{n}-1}{2}$,输出1再处理第n-<br>1行第$\left(2^{n}-1\right)-k$个就行了啊，然后迅速改了改，试了试样例都过了，极限数据也过了，然后就搞第二题了，已经过了一个小时了。 </p><p>第二题，emmmm~~，一开始感觉是可做的，然后先考虑链的情况，理解错了，设了个n方dp，试了试几组数组，成功发现思路错误，已经过了好久。心态大崩*2，于是就打了个n方与n三方直接的暴力，调试了半天。   </p><p>到第三题的时候好像还剩40多分钟，那是时内心已经绝望了，一开时想链没有什么思路，又看了看菊花图感觉讨论着好麻烦啊，又回去考虑了链的情况，想到了类似贪心的策略，一看时间还剩20分钟，果断弃疗，打了个冒泡就扔了。</p><p>唉！Day 1 就这样了。<br>晚上刷了会儿B站，心情好多了。</p><h2 id="Day-2"><a href="#Day-2" class="headerlink" title="Day 2"></a>Day 2</h2><p>真三道不可做题。太弱了，暴力都不会打，但今天心态要比昨天的好，然并卵。<br>第一道题看了40分钟，硬是没看懂题意，语文太菜了，弃了。<br>第二道暴力都不知怎么打，先过了。<br>第三题貌似还是可以水55分的，就这55分搞了半天。<br>还剩半个小时，第一题实在搞不懂，搞第二题了。打了个貌似贪心的n方，知道是错的，没法子呐！</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Day-0&quot;&gt;&lt;a href=&quot;#Day-0&quot; class=&quot;headerlink&quot; title=&quot;Day 0&quot;&gt;&lt;/a&gt;Day 0&lt;/h2&gt;&lt;p&gt;16:00到的酒店,大学还行吧。算是第二次到这里了。  &lt;/p&gt;
&lt;p&gt;考场是按姓氏排的，首字母为z的我表示很无奈，与大部队分开，只有3个人和我一起一栋楼。键盘比较新，超级nice（ps：相对于另一栋楼的键盘），屏幕还是上一次的样子，还行。在洛谷上A了到红题就走了。  &lt;/p&gt;
    
    </summary>
    
    
      <category term="travel" scheme="https://www.therehello.top/categories/travel/"/>
    
    
      <category term="游记" scheme="https://www.therehello.top/tags/%E6%B8%B8%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>noip2018</title>
    <link href="https://www.therehello.top/posts/sundries/noip2018.html/"/>
    <id>https://www.therehello.top/posts/sundries/noip2018.html/</id>
    <published>2019-11-11T16:00:00.000Z</published>
    <updated>2020-07-26T05:43:22.622Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>离第一届CSP还有4天时，考了一次noip2018。</p></blockquote><h2 id="Day-1"><a href="#Day-1" class="headerlink" title="Day 1"></a>Day 1</h2><h3 id="T1"><a href="#T1" class="headerlink" title="T1"></a>T1</h3><p>惊了，这是签到题吗？？？（ps:noip2013没做过)，思路还是比较好想的，用的线段树维护的，太菜了，还好A了，一个小时过去了。</p><a id="more"></a><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,ans;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">100505</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dd</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> minn,flag,pos;</span><br><span class="line">&#125;tree[<span class="number">405050</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">putup</span><span class="params">(<span class="keyword">int</span> pos,<span class="keyword">int</span> ls,<span class="keyword">int</span> rs)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(tree[ls].minn&lt;tree[rs].minn)&#123;</span><br><span class="line">tree[pos].minn=tree[ls].minn;</span><br><span class="line">tree[pos].pos=tree[ls].pos;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">tree[pos].minn=tree[rs].minn;</span><br><span class="line">tree[pos].pos=tree[rs].pos;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> pos,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">tree[pos].minn=a[l];</span><br><span class="line">tree[pos].pos=l;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>,ls=pos&lt;&lt;<span class="number">1</span>,rs=ls|<span class="number">1</span>;</span><br><span class="line">build(ls,l,mid);</span><br><span class="line">build(rs,mid+<span class="number">1</span>,r);</span><br><span class="line">putup(pos,ls,rs);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">putdown</span><span class="params">(<span class="keyword">int</span> pos,<span class="keyword">int</span> ls,<span class="keyword">int</span> rs)</span></span>&#123;</span><br><span class="line">tree[ls].minn+=tree[pos].flag;</span><br><span class="line">tree[rs].minn+=tree[pos].flag;</span><br><span class="line">tree[ls].flag+=tree[pos].flag;</span><br><span class="line">tree[rs].flag+=tree[pos].flag;</span><br><span class="line">tree[pos].flag=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> pos,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> ll,<span class="keyword">int</span> rr,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(ll&lt;=l&amp;&amp;r&lt;=rr)&#123;</span><br><span class="line">tree[pos].flag+=x;</span><br><span class="line">tree[pos].minn+=x;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>,ls=pos&lt;&lt;<span class="number">1</span>,rs=ls|<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(tree[pos].flag)putdown(pos,ls,rs);</span><br><span class="line"><span class="keyword">if</span>(ll&lt;=mid)modify(ls,l,mid,ll,rr,x);</span><br><span class="line"><span class="keyword">if</span>(mid&lt;rr)modify(rs,mid+<span class="number">1</span>,r,ll,rr,x);</span><br><span class="line">putup(pos,ls,rs);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">dd <span class="title">ques</span><span class="params">(<span class="keyword">int</span> pos,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> ll,<span class="keyword">int</span> rr)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(ll&lt;=l&amp;&amp;r&lt;=rr)&#123;</span><br><span class="line"><span class="keyword">return</span> tree[pos];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>,ls=pos&lt;&lt;<span class="number">1</span>,rs=ls|<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(tree[pos].flag)putdown(pos,ls,rs);</span><br><span class="line">dd minn;</span><br><span class="line">minn.minn=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">if</span>(ll&lt;=mid)minn=ques(ls,l,mid,ll,rr);</span><br><span class="line"><span class="keyword">if</span>(mid&lt;rr)&#123;</span><br><span class="line">dd noww=ques(rs,mid+<span class="number">1</span>,r,ll,rr);</span><br><span class="line"><span class="keyword">if</span>(noww.minn&lt;minn.minn)&#123;</span><br><span class="line">minn=noww;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> minn;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">dd minn=ques(<span class="number">1</span>,<span class="number">1</span>,n,l,r);</span><br><span class="line">ans+=minn.minn;</span><br><span class="line"><span class="keyword">if</span>(minn.minn)modify(<span class="number">1</span>,<span class="number">1</span>,n,l,r,-minn.minn);</span><br><span class="line"><span class="keyword">if</span>(l&lt;=minn.pos<span class="number">-1</span>)work(l,minn.pos<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">if</span>(minn.pos&lt;r)work(minn.pos+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//freopen("road.in","r",stdin);</span></span><br><span class="line"><span class="comment">//freopen("road.out","w",stdout);</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">build(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">work(<span class="number">1</span>,n);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>,ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="T2"><a href="#T2" class="headerlink" title="T2"></a>T2</h3><p>一眼想到小凯的疑惑（noip2017），然后使尽各种方法还是不会，此时已经知道第一小的一定不会被删，留下来的数绝对都是互质的，在加上T2一般都是Dp，然后就联想到了<a href="https://www.luogu.org/problem/P1474" target="_blank" rel="noopener">货币系统</a>（名字一样），给你几种面值不同的货币，让你求组成价值v方案总数。  </p><p>那么对于这道题来说，只要求出哪些数对组成不同的价值有贡献就行，然后我就让背包容量设为<em>最小互质的两个数最大不能表达的数</em>（参见小凯的疑惑）<del>是它，就是它，坑了我</del>，因为后面的数都可以被表示出来，样例对了，有手玩了几个数据也对了，可恶的是大样例在最后20分钟才发，试了一下大样例,emmm…，发现背包容量可能高达6亿….然后就把数组调到50000000就没管了。</p><p>竟然才35！！！！</p><p>唉！也不知道考场上怎么会那样想，只要求出那些数不能被其他数表示出来就okkk了啊啊啊！！！把背包容量设为最大的那个数就A了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">25550</span>];</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">50000</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(y)&#123;</span><br><span class="line"><span class="keyword">int</span> t=x%y;</span><br><span class="line">x=y;</span><br><span class="line">y=t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//freopen("money.in","r",stdin);</span></span><br><span class="line"><span class="comment">//freopen("money.out","w",stdout);</span></span><br><span class="line"><span class="keyword">int</span> t;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line"><span class="keyword">while</span>(t--)&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">memset</span>(f,<span class="number">0</span>,<span class="keyword">sizeof</span>(f));</span><br><span class="line">f[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">register</span> <span class="keyword">int</span> min1=<span class="number">0x3f3f3f3f</span>,min2=<span class="number">0x3f3f3f3f</span>,ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">sort(a+<span class="number">1</span>,a+<span class="number">1</span>+n);</span><br><span class="line"><span class="keyword">if</span>(a[<span class="number">1</span>]==<span class="number">1</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"1\n"</span>);</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">register</span> <span class="keyword">int</span> gc=<span class="number">2</span>,tail=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line"><span class="keyword">int</span> pd=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> j=a[i];j&lt;=a[n];++j)&#123;</span><br><span class="line"><span class="keyword">if</span>(f[j])<span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(f[j-a[i]])&#123;</span><br><span class="line">f[j]=<span class="number">1</span>;</span><br><span class="line">pd=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(pd)ans++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="T3"><a href="#T3" class="headerlink" title="T3"></a>T3</h3><p>一眼就不会嘛，果断的把m=1的情况给水了，然后在想怎么水一条链上的，大概就是尽量m等分，发现暴力的话复杂度太高，此时也快结束了，弃疗了。</p><p>听同学说，在一条链上，二分答案就行了。20分就这样没了。。</p><p>就水了20分，本来可以40分的。</p><p>Day 1 100+35+20=155 凉了！</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;离第一届CSP还有4天时，考了一次noip2018。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;Day-1&quot;&gt;&lt;a href=&quot;#Day-1&quot; class=&quot;headerlink&quot; title=&quot;Day 1&quot;&gt;&lt;/a&gt;Day 1&lt;/h2&gt;&lt;h3 id=&quot;T1&quot;&gt;&lt;a href=&quot;#T1&quot; class=&quot;headerlink&quot; title=&quot;T1&quot;&gt;&lt;/a&gt;T1&lt;/h3&gt;&lt;p&gt;惊了，这是签到题吗？？？（ps:noip2013没做过)，思路还是比较好想的，用的线段树维护的，太菜了，还好A了，一个小时过去了。&lt;/p&gt;
    
    </summary>
    
    
      <category term="sundries" scheme="https://www.therehello.top/categories/sundries/"/>
    
    
      <category term="杂项" scheme="https://www.therehello.top/tags/%E6%9D%82%E9%A1%B9/"/>
    
      <category term="noip/csp" scheme="https://www.therehello.top/tags/noip-csp/"/>
    
  </entry>
  
  <entry>
    <title>三元上升子序列</title>
    <link href="https://www.therehello.top/posts/notes/san_yuan_shang_sheng_xu_lie.html/"/>
    <id>https://www.therehello.top/posts/notes/san_yuan_shang_sheng_xu_lie.html/</id>
    <published>2019-10-27T16:00:00.000Z</published>
    <updated>2020-07-26T05:38:32.285Z</updated>
    
    <content type="html"><![CDATA[<h2 id="树状数组求法"><a href="#树状数组求法" class="headerlink" title="树状数组求法"></a>树状数组求法</h2><p>在做这道前，你需要了解树状数组求逆序对。</p><blockquote><p>首先看这一道题，三元！在二元时，不是跟逆序对一样吗？<br>求逆序对可以用树状数组或归并，那么在三元时，是否也可以呢？</p></blockquote><p>考虑 $a_i&lt; a_j &lt; a_k$ ，把它拆成两个二元 $a_i &lt; a_j$，$a_j &lt; a_k$ ，两个二元组都与$a_j$有关，那么就考虑中间j，假设第一个不等式有 p 个 a 满足$ &lt; a_j$，第二个有q个$a$满足$ &gt;a_j$，那么以下标为j的答案就为p*q。那不就是算一下每个下标前面比它小的值，后面比它大的值。</p><a id="more"></a><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,tree[<span class="number">33333</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dd</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> v,pos;</span><br><span class="line">&#125;a[<span class="number">33333</span>];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> ans1[<span class="number">33333</span>];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(x) ((x)&amp;(-x))</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(dd x, dd y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x.v==y.v?x.pos&gt;y.pos:x.v&lt;y.v;</span><br><span class="line">    <span class="comment">//若相同，将下标值大的放在前面。</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> t,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(t&lt;=n)&#123;</span><br><span class="line">        tree[t]+=x;</span><br><span class="line">        t+=lowbit(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tot=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(t)&#123;</span><br><span class="line">        tot+=tree[t];</span><br><span class="line">        t-=lowbit(t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> ch=getchar();</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;<span class="string">'9'</span>||ch&lt;<span class="string">'0'</span>)ch=getchar();</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">'0'</span>&amp;&amp;ch&lt;=<span class="string">'9'</span>)&#123;</span><br><span class="line">        x=x*<span class="number">10</span>+(ch^<span class="number">48</span>);</span><br><span class="line">        ch=getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n=read();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        a[i].v=read();</span><br><span class="line">        a[i].pos=i;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(a+<span class="number">1</span>,a+<span class="number">1</span>+n,cmp);<span class="comment">//从小到大排序</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        ans1[i]=sum(a[i].pos<span class="number">-1</span>);</span><br><span class="line">        <span class="comment">//下标大的先计算，不会影响下标比它小相同数的统计</span></span><br><span class="line">        update(a[i].pos,<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(tree,<span class="number">0</span>,<span class="keyword">sizeof</span>(tree));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&gt;=<span class="number">1</span>;--i)&#123;</span><br><span class="line">        <span class="comment">//倒序枚举，此时是下标小先计算，不会影响下标比它大相同数的统计</span></span><br><span class="line">        ans+=(<span class="keyword">long</span> <span class="keyword">long</span>)ans1[i]*(sum(n-a[i].pos));</span><br><span class="line">        update(n-a[i].pos+<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld"</span>,ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此题可以拓展到k元上升序列，推荐个<a href="https://www.luogu.org/blog/huangchangmiao/solution-p1637" target="_blank" rel="noopener">大佬博客</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;树状数组求法&quot;&gt;&lt;a href=&quot;#树状数组求法&quot; class=&quot;headerlink&quot; title=&quot;树状数组求法&quot;&gt;&lt;/a&gt;树状数组求法&lt;/h2&gt;&lt;p&gt;在做这道前，你需要了解树状数组求逆序对。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;首先看这一道题，三元！在二元时，不是跟逆序对一样吗？&lt;br&gt;求逆序对可以用树状数组或归并，那么在三元时，是否也可以呢？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;考虑 $a_i&amp;lt; a_j &amp;lt; a_k$ ，把它拆成两个二元 $a_i &amp;lt; a_j$，$a_j &amp;lt; a_k$ ，两个二元组都与$a_j$有关，那么就考虑中间j，假设第一个不等式有 p 个 a 满足$ &amp;lt; a_j$，第二个有q个$a$满足$ &amp;gt;a_j$，那么以下标为j的答案就为p*q。那不就是算一下每个下标前面比它小的值，后面比它大的值。&lt;/p&gt;
    
    </summary>
    
    
      <category term="notes" scheme="https://www.therehello.top/categories/notes/"/>
    
    
      <category term="题解" scheme="https://www.therehello.top/tags/%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>黑红树</title>
    <link href="https://www.therehello.top/posts/notes/hei_hong_shu.html/"/>
    <id>https://www.therehello.top/posts/notes/hei_hong_shu.html/</id>
    <published>2019-10-25T16:00:00.000Z</published>
    <updated>2020-07-26T05:38:59.323Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><pre><code>Czy发现黑红树具有一些独特的性质。</code></pre><ol><li>这是二叉树，除根节点外每个节点都有红与黑之间的一种颜色。</li><li>每个节点的两个儿子节点都被染成恰好一个红色一个黑色。</li><li>这棵树你是望不到头的（树的深度可以到无限大）</li><li>黑红树上的高度这样定义:h(根节点)=0，h[son]=h[father]+1。<a id="more"></a></li></ol><p>Czy想从树根顺着树往上爬。他有p/q的概率到达红色的儿子节点，有1-p/q的概率到达黑色节点。但是他知道如果自己经过的路径是不平衡的，他会马上摔下来。一条红黑树上的链是不平衡的，当且仅当红色节点与黑色节点的个数之差大于1。现在他想知道他刚好在高度为h的地方摔下来的概率的精确值a/b，gcd(a,b)=0。那可能很大，所以他只要知道a,b对K取模的结果就可以了。另外，czy对输入数据加密：第i个询问Qi真正大小将是给定的Q减上一个询问的第一个值a%K.</p><h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h2><p>第一行四个数p,q,T,k，表示走红色节点概率是p/q，以下T组询问，答案对K取模。接下来T行，每行一个数 Q,表示czy想知道刚好在高度Q掉下来的概率（已加密）<br>输出T行，每行两个整数，表示要求的概率a/b中a%K和b%K的精确值。如果这个概率就是0或1，直接输出0 0或1 1（中间有空格）。</p><h2 id="样例输入1"><a href="#样例输入1" class="headerlink" title="样例输入1"></a>样例输入1</h2><blockquote><p>2 3 2 100<br>1<br>2</p></blockquote><h2 id="样例输出1"><a href="#样例输出1" class="headerlink" title="样例输出1"></a>样例输出1</h2><blockquote><p>0 0<br>5 9</p></blockquote><h2 id="样例输入2"><a href="#样例输入2" class="headerlink" title="样例输入2"></a>样例输入2</h2><blockquote><p>2 3 2 20<br>4<br>6</p></blockquote><h2 id="样例输出2"><a href="#样例输出2" class="headerlink" title="样例输出2"></a>样例输出2</h2><blockquote><p>0 1<br>0 9</p></blockquote><p>这道题的求解顺序应是：求值-&gt;化简-&gt;取模，不能错，<del>错了就是见祖宗</del>。<br>明显的是在奇数层绝对是不会掉下来的，那么就把二层看作一层进行dp。<br>那么在h层刚好掉下来的概率是h-2层活下来的概率 * 连续走两次一样的概率，就是$\frac{p^2}{q^2}+\frac{(p-q)^2}{q^2}$，化简一下就好了<del>。<br>那么对活下来的概率dp就行了，（准确来说是递推），应该好搞吧</del>，在h层活的概率就是h-2层活的概率 * 走两次不一样的概率（ps：因为可以先红后黑，或先黑后红，所以要乘2），式子是$\frac{2p(p-q)}{q^2}$。<br>对活下来的概率先预处理一波，然后询问的话O(1)回答；其实活下来的概率是个等比数列，写出通项公式，对于每个询问进行快速幂运算就好了。<br>想说明的一点是取模之后再约分是不对的，要先把式子约分，这样可以保证算出来的答案一定是真正答案模意义下的，这道题就这个样子。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> p,q,t,k;</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">2</span>][<span class="number">1010101</span>],die[<span class="number">2</span>],live[<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> x=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> ch=getchar();</span><br><span class="line"><span class="keyword">while</span>(ch&lt;<span class="string">'0'</span>||ch&gt;<span class="string">'9'</span>)ch=getchar();</span><br><span class="line"><span class="keyword">while</span>(ch&gt;=<span class="string">'0'</span>&amp;&amp;ch&lt;=<span class="string">'9'</span>)&#123;</span><br><span class="line">x=x*<span class="number">10</span>+(ch^<span class="number">48</span>);</span><br><span class="line">ch=getchar();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tep;</span><br><span class="line">    <span class="keyword">while</span>(y!=<span class="number">0</span>)&#123;</span><br><span class="line">        tep=x%y;</span><br><span class="line">        x=y;</span><br><span class="line">        y=tep;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ready</span><span class="params">()</span></span>&#123;</span><br><span class="line">     dp[<span class="number">0</span>][<span class="number">0</span>]=dp[<span class="number">1</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">500000</span>;++i)&#123;</span><br><span class="line">         dp[<span class="number">0</span>][i]=((<span class="keyword">long</span> <span class="keyword">long</span>)dp[<span class="number">0</span>][i<span class="number">-1</span>]*(<span class="keyword">long</span> <span class="keyword">long</span>)live[<span class="number">0</span>])%(<span class="keyword">long</span> <span class="keyword">long</span>)k;</span><br><span class="line">         dp[<span class="number">1</span>][i]=((<span class="keyword">long</span> <span class="keyword">long</span>)dp[<span class="number">1</span>][i<span class="number">-1</span>]*(<span class="keyword">long</span> <span class="keyword">long</span>)live[<span class="number">1</span>])%(<span class="keyword">long</span> <span class="keyword">long</span>)k;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    p=read();q=read();t=read();k=read();</span><br><span class="line">    <span class="keyword">int</span> gcd_=gcd(p,q);</span><br><span class="line">    p/=gcd_;q/=gcd_;</span><br><span class="line">    die[<span class="number">0</span>]=<span class="number">2</span>*p*p+q*q<span class="number">-2</span>*p*q;</span><br><span class="line">    die[<span class="number">1</span>]=q*q;</span><br><span class="line">    gcd_=gcd(die[<span class="number">0</span>],die[<span class="number">1</span>]);</span><br><span class="line">    die[<span class="number">0</span>]/=gcd_;die[<span class="number">1</span>]/=gcd_;</span><br><span class="line">    live[<span class="number">0</span>]=p*(q-p)*<span class="number">2</span>;</span><br><span class="line">    live[<span class="number">1</span>]=q*q;</span><br><span class="line">    gcd_=gcd(live[<span class="number">0</span>],live[<span class="number">1</span>]);</span><br><span class="line">    live[<span class="number">0</span>]/=gcd_;live[<span class="number">1</span>]/=gcd_;</span><br><span class="line">    ready();</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">int</span> x,y=<span class="number">0</span>,z;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        x=read();</span><br><span class="line">        x-=y;</span><br><span class="line">        <span class="keyword">if</span>((x&amp;<span class="number">1</span>)||(x&lt;=<span class="number">0</span>))&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"0 0\n"</span>);</span><br><span class="line">            y=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        y=((<span class="keyword">long</span> <span class="keyword">long</span>)dp[<span class="number">0</span>][(x&gt;&gt;<span class="number">1</span>)<span class="number">-1</span>]*die[<span class="number">0</span>])%k;</span><br><span class="line">        z=((<span class="keyword">long</span> <span class="keyword">long</span>)dp[<span class="number">1</span>][(x&gt;&gt;<span class="number">1</span>)<span class="number">-1</span>]*die[<span class="number">1</span>])%k;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>,y,z);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;Czy发现黑红树具有一些独特的性质。&lt;/code&gt;&lt;/pre&gt;&lt;ol&gt;
&lt;li&gt;这是二叉树，除根节点外每个节点都有红与黑之间的一种颜色。&lt;/li&gt;
&lt;li&gt;每个节点的两个儿子节点都被染成恰好一个红色一个黑色。&lt;/li&gt;
&lt;li&gt;这棵树你是望不到头的（树的深度可以到无限大）&lt;/li&gt;
&lt;li&gt;黑红树上的高度这样定义:h(根节点)=0，h[son]=h[father]+1。
    
    </summary>
    
    
      <category term="notes" scheme="https://www.therehello.top/categories/notes/"/>
    
    
      <category term="题解" scheme="https://www.therehello.top/tags/%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>树【树形Dp】</title>
    <link href="https://www.therehello.top/posts/notes/shu_xing_Dp.html/"/>
    <id>https://www.therehello.top/posts/notes/shu_xing_Dp.html/</id>
    <published>2019-10-20T16:00:00.000Z</published>
    <updated>2020-07-26T05:38:15.193Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p> 图论中的树为一个无环的无向图。给定一棵树，每个节点有一盏指示灯和一个按钮。如果节点的按扭被按了，那么该节点的灯会从熄灭变为点亮（当按之前是熄灭的），或者从点亮到熄灭（当按之前是点亮的）。并且该节点的直接邻居也发生同样的变化。</p><a id="more"></a><p> 开始的时候，所有的指示灯都是熄灭的。请编程计算最少要按多少次按钮，才能让所有节点的指示灯变为点亮状态。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入文件有多组数据。</p><p>输入第一行包含一个整数n，表示树的节点数目。每个节点的编号从1到n。</p><p>输入接下来的n – 1行，每一行包含两个整数x，y，表示节点x和y之间有一条无向边。</p><p>当输入n为0时，表示输入结束。</p><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h2><p>3<br>1 2<br>1 3</p><h2 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h2><p>1 </p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>对于每组数据，输出最少要按多少次按钮，才能让所有节点的指示灯变为点亮状态。每一组数据独占一行。</p><p>$f_{i,0}$表示以$i$为根的子树都亮，并且$i$开<br>$f_{i,1}$表示以$i$为根的子辈都亮，$i$没开，$i$亮<br>$f_{i,2}$表示以$i$为根的子辈都亮，$i$没开，$i$不亮<br>$s=\sum_j min(f_{j,0},f_{j,1})$<br>初始t = 0<br>if($f_{j,0}&lt;f_{j,1}$)$t$^$=1$<br>t = 0 代表着 i 不会亮，t = 1 就代表着 i 会亮<br>$minn=min(abs(f_{j,0}-f_{j,1}))$<br>$f_{i,1}=s+(t?0:minn)$<br>$f_{i,2}=s+(t?minn,0)$<br>$f_{i,0}=\sum_{j}f_{j,2}+1$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> add(x,y) edge[++tail]=(dd)&#123;head[x],y&#125;;head[x]=tail;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dd</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> ne,to;</span><br><span class="line">&#125;edge[<span class="number">500</span>];</span><br><span class="line"><span class="keyword">int</span> head[<span class="number">111</span>],tail,n;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> f[<span class="number">111</span>][<span class="number">3</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> t,<span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">    f[t][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> tt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> minn=<span class="number">1000000</span>,s=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[t];i;i=edge[i].ne)&#123;</span><br><span class="line">        <span class="keyword">if</span>(edge[i].to!=fa)&#123;</span><br><span class="line">            dfs(edge[i].to,t);</span><br><span class="line">            s+=min(f[edge[i].to][<span class="number">1</span>],f[edge[i].to][<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">if</span>(f[edge[i].to][<span class="number">0</span>]&lt;f[edge[i].to][<span class="number">1</span>])tt^=<span class="number">1</span>;</span><br><span class="line">            minn=min(minn,<span class="built_in">abs</span>(f[edge[i].to][<span class="number">1</span>]-f[edge[i].to][<span class="number">0</span>]));</span><br><span class="line">            f[t][<span class="number">0</span>]+=f[edge[i].to][<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    f[t][<span class="number">1</span>]=s+(tt?<span class="number">0</span>:minn);</span><br><span class="line">    f[t][<span class="number">2</span>]=s+(tt?minn:<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(head,<span class="number">0</span>,<span class="keyword">sizeof</span>(head));</span><br><span class="line">        <span class="built_in">memset</span>(f,<span class="number">0</span>,<span class="keyword">sizeof</span>(f));      </span><br><span class="line">        tail=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,x,y;i&lt;n;++i)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y);</span><br><span class="line">            add(x,y);add(y,x);</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,min(f[<span class="number">1</span>][<span class="number">0</span>],f[<span class="number">1</span>][<span class="number">1</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt; 图论中的树为一个无环的无向图。给定一棵树，每个节点有一盏指示灯和一个按钮。如果节点的按扭被按了，那么该节点的灯会从熄灭变为点亮（当按之前是熄灭的），或者从点亮到熄灭（当按之前是点亮的）。并且该节点的直接邻居也发生同样的变化。&lt;/p&gt;
    
    </summary>
    
    
      <category term="notes" scheme="https://www.therehello.top/categories/notes/"/>
    
    
      <category term="题解" scheme="https://www.therehello.top/tags/%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>开启Valine评论功能</title>
    <link href="https://www.therehello.top/posts/shi_yong/Valine.html/"/>
    <id>https://www.therehello.top/posts/shi_yong/Valine.html/</id>
    <published>2019-10-14T16:00:00.000Z</published>
    <updated>2020-08-16T03:21:57.195Z</updated>
    
    <content type="html"><![CDATA[<p>首先需要在<a href="https://leancloud.cn/" target="_blank" rel="noopener">Leancloud官网</a>注册并登录，然后点击创建应用（ps：应用名称最好填你的博客名，这是为了邮箱提醒）。</p><a id="more"></a><p><img src="https://s2.ax1x.com/2019/10/28/KcHbeH.png" alt=""></p><p>创建好应用后，点击应用设置，找到应用Keys，将箭头所指的两个复制下来。<br><img src="https://s2.ax1x.com/2019/10/28/KcHLTA.png" alt=""></p><p>打开你的博客下的themes/***/_config.yml，找到如下图的内容，将它们粘贴上去。<br><img src="https://s2.ax1x.com/2019/10/28/KcHqwd.png" alt=""></p><p>在Leancloud中设置-安全中心-web安全域名中输入你的网站。（这一步貌似可以跳过）</p><p>之后</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><p>就算是初步打造好了。</p><p>如果你想要开启邮箱提醒，在主题配置里设置notify为true。<br>回到Leancloud,进行如下操作。<br><img src="https://s2.ax1x.com/2019/10/28/KcO074.png" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">你在 &#123;&#123;appname&#125;&#125;博客中的评论收到了新的回复</span><br><span class="line"></span><br><span class="line">&lt;p&gt;Hi, &#123;&#123;username&#125;&#125;&lt;&#x2F;p&gt;</span><br><span class="line">&lt;p&gt;</span><br><span class="line">你在 &#123;&#123;appname&#125;&#125; 的博客中的评论收到了新的回复，请点击查看：</span><br><span class="line">&lt;&#x2F;p&gt;</span><br><span class="line">&lt;p&gt;&lt;a href&#x3D;&quot;你的网站主&quot; style&#x3D;&quot;display: inline-block; padding: 10px 20px; border-radius: 4px; background-color: #3090e4; color: #fff; text-decoration: none;&quot;&gt;马上查看&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;</span><br></pre></td></tr></table></figure><p>如何还有疑问，请评论或访问<a href="https://valine.js.org" target="_blank" rel="noopener">Valine官网</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;首先需要在&lt;a href=&quot;https://leancloud.cn/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Leancloud官网&lt;/a&gt;注册并登录，然后点击创建应用（ps：应用名称最好填你的博客名，这是为了邮箱提醒）。&lt;/p&gt;
    
    </summary>
    
    
      <category term="shi_yong" scheme="https://www.therehello.top/categories/shi-yong/"/>
    
    
      <category term="实用" scheme="https://www.therehello.top/tags/%E5%AE%9E%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>飞行路线 改造路 分层最短路【模板】</title>
    <link href="https://www.therehello.top/posts/notes/fen_ceng_zui_duan_lu.html/"/>
    <id>https://www.therehello.top/posts/notes/fen_ceng_zui_duan_lu.html/</id>
    <published>2019-10-13T16:00:00.000Z</published>
    <updated>2020-07-26T05:38:39.408Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.luogu.org/problem/P4568" target="_blank" rel="noopener">P4568</a>　<a href="https://www.luogu.org/problem/P2939" target="_blank" rel="noopener">P2939</a></p><blockquote><p>给你一张带权图,你可以用不大于K次机会免费通过一条边(或者是以其他费用通过),问你从起点到终点最短路径.</p></blockquote><p>分层最短路就是用来处理这一问题的,其实就是变了点形的Dp,只是名字高级了一点.貌似也只能处理这一问题了.$Dp$无非就是设$dp[i][j]$,其意就是到达$i$点用了$j$次机会所用的最小花费.</p><a id="more"></a><p>而分层最短路大概就是把图扩充为好几层,每一层代表的含义就是使用了几次机会.如果到了下一层那么就是免费(或其他),在这一层里走就是正常花费.其实还是挺好理解的(Ps:只是把二维的Dp变成了一维).</p><p><img src="https://s2.ax1x.com/2019/10/15/KCyZPe.png" alt=""></p><p>而且代码只是在最短路的代码上多连了几条边,一般都是用堆优化的$Dij$跑,因为给你的点数一般为10000,而且边不算稀,用SPFA较慢.上代码.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Mystruct</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> ne,to,w;</span><br><span class="line">&#125;edge[<span class="number">4105050</span>];</span><br><span class="line"><span class="keyword">int</span> n,m,k,head[<span class="number">212020</span>],tail,dis[<span class="number">212020</span>];</span><br><span class="line"><span class="keyword">bool</span> v[<span class="number">212020</span>];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> add(x,y,z) edge[++tail].ne=head[x];edge[tail].to=y;edge[tail].w=z;head[x]=tail;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dij</span><span class="params">()</span></span>&#123;</span><br><span class="line">priority_queue&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; &gt;q;</span><br><span class="line"><span class="comment">//用优先队列码量小,跟堆的作用一样</span></span><br><span class="line"><span class="comment">//pair为二元组,把俩者绑在一起,默认的是先从第一个比较大小,若相等则比较第二个</span></span><br><span class="line"><span class="comment">//此时这里默认的是大根堆,此时可以自定义比较,或者把dis把它变成负的就ok了</span></span><br><span class="line"><span class="comment">//可以这样  priority_queue&lt;pair&lt;int,int&gt;,vector&lt;pair&lt;int,int&gt; &gt;,greater&lt;pair&lt;int,int&gt; &gt; &gt;q</span></span><br><span class="line"><span class="comment">//又长又臭, 倾向于第二种</span></span><br><span class="line">q.push(make_pair(<span class="number">0</span>,<span class="number">1</span>));<span class="comment">//就当起点是1,终点是N了</span></span><br><span class="line"><span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line"><span class="keyword">int</span> x=q.top().second;</span><br><span class="line"><span class="comment">//pair以 .first 访问第一个,以 .second 访问第二个</span></span><br><span class="line">q.pop();</span><br><span class="line"><span class="keyword">if</span>(v[x])<span class="keyword">continue</span>;</span><br><span class="line">v[x]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];i;i=edge[i].ne)&#123;</span><br><span class="line"><span class="keyword">int</span> diss=dis[x]+edge[i].w;</span><br><span class="line"><span class="keyword">if</span>(dis[edge[i].to]&gt;=diss)&#123;</span><br><span class="line">dis[edge[i].to]=diss;</span><br><span class="line">q.push(make_pair(-diss,edge[i].to));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;n,&amp;m,&amp;k);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,x,y,z;i&lt;=m;++i)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;x,&amp;y,&amp;z);</span><br><span class="line">add(x,y,z);</span><br><span class="line">add(y,x,z);</span><br><span class="line"><span class="comment">//第0层互相连边</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=k;++j)&#123;</span><br><span class="line">add(x+(j<span class="number">-1</span>)*n,y+j*n,<span class="number">0</span>);</span><br><span class="line">add(y+(j<span class="number">-1</span>)*n,x+j*n,<span class="number">0</span>);</span><br><span class="line"><span class="comment">//第j-1层与第j层连边</span></span><br><span class="line">add(y+j*n,x+j*n,z);</span><br><span class="line">add(x+j*n,y+j*n,z);</span><br><span class="line"><span class="comment">//第j层互相连边</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n*(k+<span class="number">1</span>);++i)</span><br><span class="line">dis[i]=<span class="number">0x7fffffff</span>;</span><br><span class="line">dis[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">dij();</span><br><span class="line"><span class="keyword">int</span> ans=<span class="number">0x7fffffff</span>;</span><br><span class="line"><span class="comment">//别忘了可能还没用够K次机会就到终点了</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&lt;=n*(k+<span class="number">1</span>);i+=n)</span><br><span class="line">ans=min(ans,dis[i]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>,ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://www.luogu.org/problem/P4568&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;P4568&lt;/a&gt;　&lt;a href=&quot;https://www.luogu.org/problem/P2939&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;P2939&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;给你一张带权图,你可以用不大于K次机会免费通过一条边(或者是以其他费用通过),问你从起点到终点最短路径.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;分层最短路就是用来处理这一问题的,其实就是变了点形的Dp,只是名字高级了一点.貌似也只能处理这一问题了.$Dp$无非就是设$dp[i][j]$,其意就是到达$i$点用了$j$次机会所用的最小花费.&lt;/p&gt;
    
    </summary>
    
    
      <category term="notes" scheme="https://www.therehello.top/categories/notes/"/>
    
    
      <category term="题解" scheme="https://www.therehello.top/tags/%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>中山8.23</title>
    <link href="https://www.therehello.top/posts/travel/Zhongshan/8.23.html/"/>
    <id>https://www.therehello.top/posts/travel/Zhongshan/8.23.html/</id>
    <published>2019-08-23T00:00:00.000Z</published>
    <updated>2020-07-26T05:46:26.173Z</updated>
    
    <content type="html"><![CDATA[<h2 id="今日总结"><a href="#今日总结" class="headerlink" title="今日总结"></a>今日总结</h2><a id="more"></a><h3 id="T1"><a href="#T1" class="headerlink" title="T1:"></a>T1:</h3><p>感觉题目说的有点小问题(<del>还是太菜le</del>),导致我做法比较玄学…搞了70分.</p><h3 id="T2"><a href="#T2" class="headerlink" title="T2:"></a>T2:</h3><p>裸啊!(<del>还是不会</del>)根据题意可以转化成n个相同的小球放进m个不同的盒子里,不允许为空.用隔板法(<del>通过背结论</del>)可以推出方案数为$c_{n-1}^{m-1}$,emmm…我没背啊!!!</p><p>（以下为口胡,<del>有错别怪我</del>）但我发现可以通过数的划分变形得到,$(1,1,2)$,$(1,2,1)$,$(2,1,1)$在这道题中为3中不同的方案,但在数的划分中认为是同一种方案,但我每得到一种答案,就把它乘不全相异元素排列方案数<br>(  $\frac {n!}{n_{1}!<em>n_2!</em>…n_{m-1}!*n_m!}$  )…就ok了…但在码时,我发现我数的划分也不会了..凉!</p><h3 id="T3"><a href="#T3" class="headerlink" title="T3:"></a>T3:</h3><p>先鸽着…题懒得看了</p><h3 id="T4"><a href="#T4" class="headerlink" title="T4:"></a>T4:</h3><p>emmmm….只做过一维的，二维的是什么鬼….</p><p>正解: 三维偏序???</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;今日总结&quot;&gt;&lt;a href=&quot;#今日总结&quot; class=&quot;headerlink&quot; title=&quot;今日总结&quot;&gt;&lt;/a&gt;今日总结&lt;/h2&gt;
    
    </summary>
    
    
      <category term="travel" scheme="https://www.therehello.top/categories/travel/"/>
    
      <category term="Zhongshan" scheme="https://www.therehello.top/categories/travel/Zhongshan/"/>
    
    
      <category term="中山" scheme="https://www.therehello.top/tags/%E4%B8%AD%E5%B1%B1/"/>
    
  </entry>
  
  <entry>
    <title>中山8.21</title>
    <link href="https://www.therehello.top/posts/travel/Zhongshan/8.21.html/"/>
    <id>https://www.therehello.top/posts/travel/Zhongshan/8.21.html/</id>
    <published>2019-08-21T00:00:00.000Z</published>
    <updated>2020-07-26T05:46:16.509Z</updated>
    
    <content type="html"><![CDATA[<h2 id="今日总结"><a href="#今日总结" class="headerlink" title="今日总结"></a>今日总结</h2><a id="more"></a><h4 id="都不会！！！"><a href="#都不会！！！" class="headerlink" title="都不会！！！"></a>都不会！！！</h4><h4 id="T1"><a href="#T1" class="headerlink" title="T1:"></a>T1:</h4><p>最小生成树???最小比例生成树….我想着用状压枚举哪些点选…然后想了想点之间可能会很多边,不会处理(蒟蒻一个),果断放弃.</p><p>正解是跑好几遍最小生成树….</p><h4 id="T2"><a href="#T2" class="headerlink" title="T2:"></a>T2:</h4><p>完全不会,没往$Dp$上想…</p><p>设$Dp[i][j]$为第$i$个人什么的,<del>让我再想想</del>.</p><h4 id="T3"><a href="#T3" class="headerlink" title="T3:"></a>T3:</h4><p>凭借这10%的数据$n=0$水了十分…然后就不会了…</p><p>把球心和起点与终点互相连起来,距离就是点之间的距离减上两个点所在的球的半径…跑一边$Dij$就ok了.</p><h4 id="T4"><a href="#T4" class="headerlink" title="T4:"></a>T4:</h4><p>想法和正解相差甚远…想着有什么奇淫技巧…结果这么暴力.</p><p>跑一遍最短路,然后枚举删哪一个点,然后再跑最短路,再枚举…知道最短路径大于$k$.<del>这么暴力的吗</del></p><p>争取把今天题改完吧(也许可能吧.</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;今日总结&quot;&gt;&lt;a href=&quot;#今日总结&quot; class=&quot;headerlink&quot; title=&quot;今日总结&quot;&gt;&lt;/a&gt;今日总结&lt;/h2&gt;
    
    </summary>
    
    
      <category term="travel" scheme="https://www.therehello.top/categories/travel/"/>
    
      <category term="Zhongshan" scheme="https://www.therehello.top/categories/travel/Zhongshan/"/>
    
    
      <category term="中山" scheme="https://www.therehello.top/tags/%E4%B8%AD%E5%B1%B1/"/>
    
  </entry>
  
  <entry>
    <title>中山8.20</title>
    <link href="https://www.therehello.top/posts/travel/Zhongshan/8.20.html/"/>
    <id>https://www.therehello.top/posts/travel/Zhongshan/8.20.html/</id>
    <published>2019-08-20T00:00:00.000Z</published>
    <updated>2020-07-26T05:46:08.590Z</updated>
    
    <content type="html"><![CDATA[<h2 id="今日总结"><a href="#今日总结" class="headerlink" title="今日总结"></a>今日总结</h2><a id="more"></a><h3 id="T1"><a href="#T1" class="headerlink" title="T1:"></a>T1:</h3><p>表示完全没有思路，于是就打起了贪心,然后0分??? (之前贪心总能拿点分呐!)</p><p>正解是dp乱搞???</p><h3 id="T2"><a href="#T2" class="headerlink" title="T2:"></a>T2:</h3><p>就这道题有点思想了,结果样例没看懂…</p><p>正解还是dp…设$f[i]$为i个时间内回到家的方案数,在这i个时间内可能经过家,也可能没有经过.这..这不就是卡特兰数吗?但不是…因为在这道题中限制了在最多m个时间内回到家.</p><p>再设$Dp[i]$为i个时间内刚好回到家的方案数,在这i个时间内没有经过家,则$f[i]=\sum_{j=1}^{min(i,m)}{f[i-j]*Dp[j]}$.这个$Dp[i]$也形似卡特兰数,可惜也不是,因为卡特兰数0可以与1相等,不符合我们的要求,但我们可以略加改进.</p><p>考虑卡特兰数可以走到对角线上,但我们并不想让它走到上面,于是我们在这个对角线下再画一条线,先向右走1格,求出到从(0,1)到(5,4)的方案数即可.在这道题中即可以先向左,也可以先向右.所以将求出的方案数*2即可.</p><p>如图所示：</p><p><img src="https://s2.ax1x.com/2019/08/21/mN3kiF.png" alt=""></p><p>由于n比较大，所以需要用矩阵快速幂优化,这里就跳过了.</p><h3 id="T3："><a href="#T3：" class="headerlink" title="T3："></a>T3：</h3><p>完全没得思路,想找循环发现不是,于是果断暴力走起。</p><p>正解是<del>神仙</del>类欧???  不会…</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;今日总结&quot;&gt;&lt;a href=&quot;#今日总结&quot; class=&quot;headerlink&quot; title=&quot;今日总结&quot;&gt;&lt;/a&gt;今日总结&lt;/h2&gt;
    
    </summary>
    
    
      <category term="travel" scheme="https://www.therehello.top/categories/travel/"/>
    
      <category term="Zhongshan" scheme="https://www.therehello.top/categories/travel/Zhongshan/"/>
    
    
      <category term="中山" scheme="https://www.therehello.top/tags/%E4%B8%AD%E5%B1%B1/"/>
    
  </entry>
  
  <entry>
    <title>中山8.9</title>
    <link href="https://www.therehello.top/posts/travel/Zhongshan/8.9.html/"/>
    <id>https://www.therehello.top/posts/travel/Zhongshan/8.9.html/</id>
    <published>2019-08-20T00:00:00.000Z</published>
    <updated>2020-07-26T05:45:17.895Z</updated>
    
    <content type="html"><![CDATA[<h2 id="今日总结"><a href="#今日总结" class="headerlink" title="今日总结"></a>今日总结</h2><a id="more"></a><p>T1. 水（<del>可惜我不会打…</del>）</p><p>先bfs跑一遍洪水泛滥的，记录一下每个位置在哪一秒时被淹了。然后再bfs跑一遍人,在下一个时刻不能跑洪水泛滥的以及石头所在的，直到遇到住所中break就行了。</p><p>T2. 是一道状压题（<del>没看出来…</del>）跟棋盘放置差不多</p><p>打的dfs，死活printf不了long double,然后就手动保留小数（忘了进位问题…)然后就40。原来要用%Lf输出，95呐，就超时了一个点（<del>还是数据水</del>）</p><p>T3. 单调栈（<del>没听过…</del>)</p><p>T4. Tarjan缩点乱搞（<del>不会不会</del>）</p><hr><h4 id="看来不会的还有很多呐！数据结构方面要加强，图论要加强，dp要加强，模拟要加强。（貌似吧考的都说完了）"><a href="#看来不会的还有很多呐！数据结构方面要加强，图论要加强，dp要加强，模拟要加强。（貌似吧考的都说完了）" class="headerlink" title="看来不会的还有很多呐！数据结构方面要加强，图论要加强，dp要加强，模拟要加强。（貌似吧考的都说完了）"></a>看来不会的还有很多呐！数据结构方面要加强，图论要加强，dp要加强，模拟要加强。（<del>貌似吧考的都说完了</del>）</h4>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;今日总结&quot;&gt;&lt;a href=&quot;#今日总结&quot; class=&quot;headerlink&quot; title=&quot;今日总结&quot;&gt;&lt;/a&gt;今日总结&lt;/h2&gt;
    
    </summary>
    
    
      <category term="travel" scheme="https://www.therehello.top/categories/travel/"/>
    
      <category term="Zhongshan" scheme="https://www.therehello.top/categories/travel/Zhongshan/"/>
    
    
      <category term="中山" scheme="https://www.therehello.top/tags/%E4%B8%AD%E5%B1%B1/"/>
    
  </entry>
  
  <entry>
    <title>点的距离【欧拉序列】</title>
    <link href="https://www.therehello.top/posts/notes/dian_de_ju_li.html/"/>
    <id>https://www.therehello.top/posts/notes/dian_de_ju_li.html/</id>
    <published>2019-08-15T00:00:00.000Z</published>
    <updated>2020-07-26T05:38:46.422Z</updated>
    
    <content type="html"><![CDATA[<h4 id="原题链接：点的距离loj10130"><a href="#原题链接：点的距离loj10130" class="headerlink" title="原题链接：点的距离loj10130"></a>原题链接：<a href="https://loj.ac/problem/10130" target="_blank" rel="noopener">点的距离loj10130</a></h4><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一棵 N个点的树，Q个询问，每次询问点x到点y两点之间的距离。</p><a id="more"></a><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行一个正整数N，表示这棵树有 N个节点；</p><p>接下来N-1行，每行两个整数x y表示x，y有两条连边</p><p>然后一个整数Q，表示有Q个询问</p><p>接下来Q行每行两个整数x y 表示询问x到y的距离</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出Q行，每行表示每个询问的答案。</p><h2 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span></span><br><span class="line"><span class="number">2</span> <span class="number">4</span></span><br><span class="line"><span class="number">2</span> <span class="number">5</span></span><br><span class="line"><span class="number">3</span> <span class="number">6</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">2</span> <span class="number">6</span></span><br><span class="line"><span class="number">5</span> <span class="number">6</span></span><br></pre></td></tr></table></figure><h2 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure><h4 id="平常在信息学竞赛中求LCA一般有四种办法："><a href="#平常在信息学竞赛中求LCA一般有四种办法：" class="headerlink" title="平常在信息学竞赛中求LCA一般有四种办法："></a>平常在信息学竞赛中求LCA一般有四种办法：</h4><ul><li><p>倍增法求解，预处理复杂度是 O(nlog⁡n) ,每次询问的复杂度是 O(log⁡n), 属于在线解法。</p></li><li><p>利用欧拉序转化为RMQ问题，用ST表求解RMQ问题，预处理复杂度 O(n+nlogn) ，每次询问的复杂度为 O(1)， 也是在线算法。</p></li><li><p>采用Tarjan算法求解，复杂度 O(α(n)+Q) ，属于离线算法。</p></li><li><p>利用树链剖分求解，复杂度预处理O(n) ，单次查询 O(log⁡n) ，属于在线算法。</p></li></ul><p>主要的为倍增法和欧拉序列</p><p>如果询问量巨大的话，欧拉序列法明显占优</p><h2 id="欧拉序-st表"><a href="#欧拉序-st表" class="headerlink" title="欧拉序+st表"></a>欧拉序+st表</h2><p>温馨提示，若想更好地阅读本文章，你需要掌握一下知识：</p><ul><li>可以dfs一棵树</li><li>熟知st表</li></ul><p>首先对有根树t进行dfs（深度优先遍历），无论是递归还是回溯，每次到达一个结点时都将深度记录下来，可以得到<strong>一个长度为2n-1的序列，称为t的欧拉序列f</strong>(类似于欧拉回路)<br>为了方便，把结点k在欧拉序列中第一次出现的序号记为pos(k)。<br>有了欧拉序列，<strong>Lca问题可以在线性时间内化为RMQ问题</strong>：<br><strong>Lca(t,u,v)=RMQ(f,pos(u),pos(v))</strong> ，这里RMQ返回的是所求值的下标，若需求两个点的距离，利用<strong>deep[u]+deep[v]-(2*deep[Lca(t,u,v)]</strong> 即可求得。</p><p>这个等式不难理解：从u走到v的过程中一定会经过Lca(t,u,v)，但不会经过Lca(t,u,v)的祖先。因此，从u走到v的过程中经过的深度最小的结点就是Lca(t,u,v)。<br>用Dfs计算欧拉序列的时间复杂度O(n)，欧拉序列的长度是2n-1，所以空间复杂度O(n)，所以Lca问题可以在O(n)的时间内用O(n)的空间转化成等规模的RMQ问题。</p><blockquote><p>此处引用刘汝佳算法竞赛入门经典</p></blockquote><p><img src="https://s2.ax1x.com/2019/09/28/u123j0.png" alt=""></p><p><img src="https://s2.ax1x.com/2019/08/21/mN3CZV.png" alt=""></p><p>Dfs计算欧拉序列：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> t, <span class="keyword">int</span> fa, <span class="keyword">int</span> deepth)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[t]; i; i = side[i].next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (side[i].to != fa) &#123;</span><br><span class="line">            Dfsxu[++tail_Dfsxu] = side[i].to;<span class="comment">//开始遍历儿子</span></span><br><span class="line">            Deep[tail_Dfsxu] = deepth + <span class="number">1</span>;</span><br><span class="line">            Dfs(side[i].to, t, deepth + <span class="number">1</span>);</span><br><span class="line">            Dfsxu[++tail_Dfsxu] = t;<span class="comment">//以儿子为根的子树已经遍历过了</span></span><br><span class="line">            Deep[tail_Dfsxu] = deepth;<span class="comment">//往回走到他爸这里，准备遍历下一个儿子</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在已经知道深度了，先预处理一下st：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">st_ready</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//由于cmath里log函数处理比较慢，这里进行预处理一下</span></span><br><span class="line">    lg[<span class="number">0</span>]=<span class="number">-1</span>;</span><br><span class="line">    mi[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= (n &lt;&lt; <span class="number">1</span>); ++i) lg[i] = lg[i &gt;&gt; <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">18</span>; ++i) mi[i] = (mi[i - <span class="number">1</span>] &lt;&lt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= lg[(n &lt;&lt; <span class="number">1</span>) - <span class="number">1</span>]; ++i)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j + mi[i] - <span class="number">1</span> &lt;= ((n &lt;&lt; <span class="number">1</span>) - <span class="number">1</span>); ++j)</span><br><span class="line">        st[i][j] = min(st[i - <span class="number">1</span>][j], st[i - <span class="number">1</span>][j + mi[i - <span class="number">1</span>]]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时已经将Lca问题转化为Rmq问题了，这时我们还需要知道每个节点在欧拉序列的第一次出现的位置，用first[i]记录当前i节点在欧拉序列中的下标，这个可以直接在求欧拉序的时候顺带求出。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> t, <span class="keyword">int</span> fa, <span class="keyword">int</span> deepth)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[t]; i; i = side[i].next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (side[i].to != fa) &#123;</span><br><span class="line">            Dfsxu[++tail_Dfsxu] = side[i].to;<span class="comment">//开始遍历儿子</span></span><br><span class="line">            Deep[tail_Dfsxu] = deepth + <span class="number">1</span>;</span><br><span class="line">    first[side[i].to] = tail_Dfsxu;<span class="comment">//这是就是个该节点第一次出现的位置</span></span><br><span class="line">            Dfs(side[i].to, t, deepth + <span class="number">1</span>);</span><br><span class="line">            Dfsxu[++tail_Dfsxu] = t;<span class="comment">//以儿子为根的子树已经遍历过了</span></span><br><span class="line">            Deep[tail_Dfsxu] = deepth;<span class="comment">//往回走到他爸这里，准备遍历下一个儿子</span></span><br><span class="line">            <span class="comment">//之前t已经出现了，这里就不能first记录了</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>整体思路就是这样，下面附完整代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> head[<span class="number">100011</span>], tail, tail_dfs = <span class="number">1</span>, dfsxu[<span class="number">200012</span>], n, q, lg[<span class="number">200012</span>] = &#123; <span class="number">-1</span> &#125;, mi[<span class="number">19</span>] = &#123; <span class="number">1</span> &#125;, st[<span class="number">19</span>][<span class="number">200011</span>], first[<span class="number">100012</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dd</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> next, to;</span><br><span class="line">&#125;side[<span class="number">200012</span>];<span class="comment">//邻接列表存储</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">side[++tail].to = y;</span><br><span class="line">side[tail].next = head[x];</span><br><span class="line">head[x] = tail;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> t, <span class="keyword">int</span> fa, <span class="keyword">int</span> deepth)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = head[t];i;i = side[i].next) &#123;</span><br><span class="line"><span class="keyword">if</span> (side[i].to != fa) &#123;</span><br><span class="line">dfsxu[++tail_dfs] = side[i].to;</span><br><span class="line">st[<span class="number">0</span>][tail_dfs] = deepth + <span class="number">1</span>;<span class="comment">//这里直接用st存储深度了</span></span><br><span class="line">first[side[i].to] = tail_dfs;</span><br><span class="line">dfs(side[i].to, t, deepth + <span class="number">1</span>);</span><br><span class="line">dfsxu[++tail_dfs] = t;</span><br><span class="line">st[<span class="number">0</span>][tail_dfs] = deepth;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">st_ready</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= (n &lt;&lt; <span class="number">1</span>);++i)</span><br><span class="line">lg[i] = lg[i &gt;&gt; <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">18</span>;++i)</span><br><span class="line">mi[i] = (mi[i - <span class="number">1</span>] &lt;&lt; <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= lg[(n &lt;&lt; <span class="number">1</span>) - <span class="number">1</span>];++i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>;j + mi[i] - <span class="number">1</span> &lt;= ((n &lt;&lt; <span class="number">1</span>) - <span class="number">1</span>);++j)</span><br><span class="line">st[i][j] = min(st[i - <span class="number">1</span>][j], st[i - <span class="number">1</span>][j + mi[i - <span class="number">1</span>]]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, x, y;i &lt; n;++i) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;x, &amp;y);</span><br><span class="line">add(x, y);</span><br><span class="line">add(y, x);</span><br><span class="line">&#125;</span><br><span class="line">dfsxu[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">st[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">first[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">dfs(<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">st_ready();</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;q);</span><br><span class="line"><span class="keyword">while</span> (q--) &#123;</span><br><span class="line"><span class="keyword">int</span> x, y;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;x, &amp;y);</span><br><span class="line"><span class="keyword">int</span> l = first[y], r = first[x];<span class="comment">//输入下x,y的时候，我们不知道谁先出现在欧拉序列中的， </span></span><br><span class="line"><span class="keyword">if</span> (r &lt; l)swap(l, r);        <span class="comment">//所以需要判断一下</span></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">log</span> = lg[r - l + <span class="number">1</span>];</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>, st[<span class="number">0</span>][l] + st[<span class="number">0</span>][r] - (min(st[<span class="built_in">log</span>][l], st[<span class="built_in">log</span>][r - mi[<span class="built_in">log</span>] + <span class="number">1</span>]) &lt;&lt; <span class="number">1</span>));<span class="comment">//l的深度+r的深度-公共祖先的深度*2</span></span><br><span class="line"><span class="built_in">putchar</span>(<span class="string">'\n'</span>);                                                           <span class="comment">//这个公式好理解吧</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>欢迎各位大佬指出意见</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;原题链接：点的距离loj10130&quot;&gt;&lt;a href=&quot;#原题链接：点的距离loj10130&quot; class=&quot;headerlink&quot; title=&quot;原题链接：点的距离loj10130&quot;&gt;&lt;/a&gt;原题链接：&lt;a href=&quot;https://loj.ac/problem/10130&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;点的距离loj10130&lt;/a&gt;&lt;/h4&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给定一棵 N个点的树，Q个询问，每次询问点x到点y两点之间的距离。&lt;/p&gt;
    
    </summary>
    
    
      <category term="notes" scheme="https://www.therehello.top/categories/notes/"/>
    
    
      <category term="题解" scheme="https://www.therehello.top/tags/%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://www.therehello.top/posts/first/hello-world.html/"/>
    <id>https://www.therehello.top/posts/first/hello-world.html/</id>
    <published>2019-08-14T16:00:00.000Z</published>
    <updated>2020-03-19T14:58:07.858Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><p>##Hello,world!</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;

&lt;p&gt;##Hello,world!&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="first" scheme="https://www.therehello.top/categories/first/"/>
    
    
      <category term="the first" scheme="https://www.therehello.top/tags/the-first/"/>
    
  </entry>
  
</feed>
